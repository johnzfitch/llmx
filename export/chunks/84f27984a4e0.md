---
chunk_index: 1066
ref: "84f27984a4e0"
id: "84f27984a4e06a910c6afa205c36363d1598add2afaacd729840a29f8a77a4c9"
slug: "chunk-l272-431"
path: "/home/zack/dev/llmx/ingestor-core/src/chunk.rs"
kind: "text"
lines: [272, 431]
token_estimate: 1334
content_sha256: "fd6cf06930e5adfec4d214be7cecb7cbef3d3ed28d8f6d89a1c6bafde990e3dc"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

fn normalize_html_text(input: &str) -> String {
    collapse_whitespace(&decode_html_entities(input))
}

fn should_skip_html_line(line: &str) -> bool {
    if line.is_empty() {
        return true;
    }
    match line {
        "Prev" | "Next" | "Show more" => return true,
        _ => {}
    }
    if line.len() <= 3 && line.as_bytes().iter().all(|b| b.is_ascii_digit()) {
        return true;
    }
    false
}

fn chunk_html(text: &str, options: &IngestOptions) -> Vec<ChunkDraft> {
    let mut drafts = Vec::new();
    let mut buf: Vec<String> = Vec::new();
    let mut heading_stack: Vec<String> = Vec::new();
    let mut current_heading = heading_stack.clone();
    let mut start_line = 1;
    let heading_re = Regex::new(r"(?i)<h([1-6])[^>]*>(.*?)</h[1-6]>").unwrap();
    let tag_re = Regex::new(r"<[^>]+>").unwrap();
    let mut in_script = false;
    let mut in_style = false;

    for (idx, raw_line) in text.lines().enumerate() {
        let line_no = idx + 1;
        let mut line = raw_line.to_string();
        let lower = line.to_ascii_lowercase();
        if lower.contains("<script") {
            in_script = true;
        }
        if lower.contains("</script>") {
            in_script = false;
            continue;
        }
        if lower.contains("<style") {
            in_style = true;
        }
        if lower.contains("</style>") {
            in_style = false;
            continue;
        }
        if in_script || in_style {
            continue;
        }

        if let Some(caps) = heading_re.captures(&line) {
            flush_chunk(&mut drafts, &mut buf, &current_heading, ChunkFlushParams {
                start_line,
                end_line: line_no - 1,
                kind: ChunkKind::Html,
                symbol: None,
                address: None,
            });
            let level: usize = caps.get(1).unwrap().as_str().parse().unwrap_or(1);
            let raw_title = tag_re.replace_all(caps.get(2).unwrap().as_str(), "");
            let title = normalize_html_text(raw_title.as_ref());
            while heading_stack.len() >= level {
                heading_stack.pop();
            }
            heading_stack.push(title);
            current_heading = heading_stack.clone();
            start_line = line_no;
        }

        line = tag_re.replace_all(&line, " ").to_string();
        let normalized = normalize_html_text(&line);
        if !should_skip_html_line(&normalized) {
            buf.push(normalized);
        }

        if buffer_len(&buf) >= options.chunk_max_chars {
            flush_chunk(&mut drafts, &mut buf, &current_heading, ChunkFlushParams {
                start_line,
                end_line: line_no,
                kind: ChunkKind::Html,
                symbol: None,
                address: None,
            });
            start_line = line_no + 1;
        }
    }

    flush_chunk(&mut drafts, &mut buf, &current_heading, ChunkFlushParams {
        start_line,
        end_line: line_count(text),
        kind: ChunkKind::Html,
        symbol: None,
        address: None,
    });
    drafts
}

fn chunk_json(text: &str, options: &IngestOptions) -> Vec<ChunkDraft> {
    let mut drafts = Vec::new();
    let value: serde_json::Value = match serde_json::from_str(text) {
        Ok(value) => value,
        Err(_) => {
            return chunk_text(text, options)
                .into_iter()
                .map(|draft| ChunkDraft { kind: ChunkKind::Json, ..draft })
                .collect();
        }
    };
    let line_count = line_count(text);
    match value {
        serde_json::Value::Object(map) => {
            for (key, value) in map {
                let address = format!("$.{}", key);
                let content = serde_json::to_string_pretty(&value).unwrap_or_default();
                drafts.push(ChunkDraft {
                    kind: ChunkKind::Json,
                    start_line: 1,
                    end_line: line_count,
                    content,
                    heading_path: vec![key.clone()],
                    symbol: Some(key),
                    address: Some(address),
                });
            }
        }
        serde_json::Value::Array(list) => {
            let mut start = 0usize;
            while start < list.len() {
                let end = (start + 50).min(list.len());
                let slice = &list[start..end];
                let address = format!("$[{}:{}]", start, end);
                let content = serde_json::to_string_pretty(&slice).unwrap_or_default();
                drafts.push(ChunkDraft {
                    kind: ChunkKind::Json,
                    start_line: 1,
                    end_line: line_count,
                    content,
                    heading_path: Vec::new(),
                    symbol: None,
                    address: Some(address),
                });
                start = end;
            }
        }
        _ => {
            drafts.push(ChunkDraft {
                kind: ChunkKind::Json,
                start_line: 1,
                end_line: line_count,
                content: serde_json::to_string_pretty(&value).unwrap_or_default(),
                heading_path: Vec::new(),
                symbol: None,
                address: Some("$".to_string()),
            });
        }
    }
    drafts
}