---
chunk_index: 1076
ref: "6bd8e5f39e3e"
id: "6bd8e5f39e3e0d5a6a2f53252b8456275dce414f520a79dc2ea93d43d3fb4bcc"
slug: "storage-l1-130"
path: "/home/zack/dev/llmx/ingestor-core/src/handlers/storage.rs"
kind: "text"
lines: [1, 130]
token_estimate: 1043
content_sha256: "ffc7231bf5914ce0e7f0ad4cbed7fab889e928274161c35601ec2e40893b9e8c"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

//! Index storage with in-memory cache and persistent disk backing.

use crate::{build_inverted_index, compute_stats, FileMeta, IndexFile, IndexStats};
use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, HashMap};
use std::fs;
use std::path::{Path, PathBuf};

/// Stored index format (without inverted_index for size efficiency).
#[derive(Debug, Clone, Serialize, Deserialize)]
struct StoredIndex {
    pub id: String,
    pub root_path: String,
    pub created_at: u64,
    pub files: Vec<FileMeta>,
    pub chunks: Vec<crate::Chunk>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub embeddings: Option<Vec<Vec<f32>>>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub embedding_model: Option<String>,
}

impl From<&IndexFile> for StoredIndex {
    fn from(index: &IndexFile) -> Self {
        StoredIndex {
            id: index.index_id.clone(),
            root_path: String::new(),
            created_at: std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
            files: index.files.clone(),
            chunks: index.chunks.clone(),
            embeddings: index.embeddings.clone(),
            embedding_model: index.embedding_model.clone(),
        }
    }
}

impl From<StoredIndex> for IndexFile {
    fn from(stored: StoredIndex) -> Self {
        IndexFile {
            version: 1,
            index_id: stored.id,
            files: stored.files,
            chunks: stored.chunks,
            chunk_refs: BTreeMap::new(),
            inverted_index: BTreeMap::new(),
            stats: IndexStats {
                total_files: 0,
                total_chunks: 0,
                avg_chunk_chars: 0,
                avg_chunk_tokens: 0,
            },
            warnings: vec![],
            embeddings: stored.embeddings,
            embedding_model: stored.embedding_model,
        }
    }
}

/// Registry metadata for all indexes.
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Registry {
    /// path_hash → index metadata mapping
    pub indexes: HashMap<String, IndexMetadata>,
}

/// Metadata for a single index.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IndexMetadata {
    pub id: String,
    pub root_path: String,
    pub created_at: u64,
    pub file_count: usize,
    pub chunk_count: usize,
}

/// Index storage with in-memory cache and persistent disk backing.
///
/// # Overview
///
/// `IndexStore` manages codebase indexes with a two-tier architecture:
/// 1. **Disk Storage**: Atomic writes with temp-file-and-rename pattern
/// 2. **Memory Cache**: Lazy-loaded indexes for fast repeated access
///
/// # Storage Format
///
/// - Indexes: `{storage_dir}/{index_id}.json` (without inverted index for size)
/// - Registry: `{storage_dir}/registry.json` (path → index_id mapping)
pub struct IndexStore {
    cache: HashMap<String, IndexFile>,
    storage_dir: PathBuf,
    registry: Registry,
}

impl IndexStore {
    /// Create new IndexStore with the given storage directory.
    pub fn new(storage_dir: PathBuf) -> Result<Self> {
        fs::create_dir_all(&storage_dir).context("Failed to create storage directory")?;

        let registry = Self::load_registry(&storage_dir)?;

        Ok(IndexStore {
            cache: HashMap::new(),
            storage_dir,
            registry,
        })
    }

    /// Create IndexStore with default storage directory (~/.llmx/indexes).
    pub fn default_store() -> Result<Self> {
        let storage_dir = dirs::home_dir()
            .context("Could not find home directory")?
            .join(".llmx")
            .join("indexes");
        Self::new(storage_dir)
    }

    /// Load index by ID with lazy loading and automatic inverted index rebuild.
    pub fn load(&mut self, id: &str) -> Result<&IndexFile> {
        if !self.cache.contains_key(id) {
            let stored = self.load_from_disk(id)?;
            let index = self.rebuild_index(stored)?;
            self.cache.insert(id.to_string(), index);
        }
        Ok(self.cache.get(id).unwrap())
    }