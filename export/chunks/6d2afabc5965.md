---
chunk_index: 1341
ref: "6d2afabc5965"
id: "6d2afabc5965c7c2566ac6ad590c28e9797e9bd3ee597bc635618b31d67aec51"
slug: "app--runingest"
path: "/home/zack/dev/llmx/web/app.js"
kind: "java_script"
lines: [381, 535]
token_estimate: 1323
content_sha256: "25393fc2e4bec3b706e84a63379d9c4b3125ad37f07bdc0d8984eba40ca027de"
compacted: false
heading_path: []
symbol: "runIngest"
address: null
asset_path: null
---

async function runIngest(entries, collectedMeta) {
  if (!state.workerReady) {
    setStatus("Backend not ready.");
    return;
  }
  if (!entries.length) {
    setStatus(`No supported files found. Accepted: ${ALLOWED_EXTENSIONS.join(", ")}`);
    return;
  }
  const skippedLarge = collectedMeta?.skippedLarge || 0;
  const skippedTotal = collectedMeta?.skippedTotal || 0;
  const skippedNote =
    skippedLarge || skippedTotal
      ? ` (skipped: ${skippedLarge} too large, ${skippedTotal} over total cap)`
      : "";

  const prevByPath = new Map((state.files || []).map((meta) => [meta.path, meta]));
  const currentPaths = new Set(entries.map((e) => e.path));
  let removedCount = 0;
  if (state.indexLoaded) {
    for (const path of prevByPath.keys()) {
      if (!currentPaths.has(path)) {
        removedCount += 1;
      }
    }
  }

  try {
    state.busy = true;

    if (!state.indexLoaded) {
      setStatus(`Ingesting ${entries.length} files${skippedNote}...`);
      const files = [];
      for (const entry of entries) {
        const data = await entry.file.arrayBuffer();
        files.push({
          path: entry.path,
          data,
          mtime_ms: Number.isFinite(entry.file.lastModified) ? entry.file.lastModified : null,
          fingerprint_sha256: null,
        });
      }
      const transfer = files.map((f) => f.data);
      await callWorker("ingest", { files }, state.backend?.kind === "worker" ? transfer : undefined);
    } else {
      let unchanged = 0;
      let changed = 0;
      let added = 0;
      const keepPaths = [];
      const files = [];

      for (const entry of entries) {
        const prev = prevByPath.get(entry.path);
        const isImage = isImagePath(entry.path);
        if (!prev) {
          added += 1;
          const data = await entry.file.arrayBuffer();
          files.push({
            path: entry.path,
            data,
            mtime_ms: Number.isFinite(entry.file.lastModified) ? entry.file.lastModified : null,
            fingerprint_sha256: await fingerprintFile(entry.file),
          });
          continue;
        }

        if (isImage) {
          // Always include image bytes so `export.zip` always contains the assets.
          const data = await entry.file.arrayBuffer();
          files.push({
            path: entry.path,
            data,
            mtime_ms: Number.isFinite(entry.file.lastModified) ? entry.file.lastModified : null,
            fingerprint_sha256: prev.fingerprint_sha256 || (await fingerprintFile(entry.file)),
          });
          continue;
        }

        const prevBytes = prev.bytes ?? null;
        if (prevBytes !== null && prevBytes !== entry.file.size) {
          changed += 1;
          const data = await entry.file.arrayBuffer();
          files.push({
            path: entry.path,
            data,
            mtime_ms: Number.isFinite(entry.file.lastModified) ? entry.file.lastModified : null,
            fingerprint_sha256: await fingerprintFile(entry.file),
          });
          continue;
        }

        const prevFp = prev.fingerprint_sha256 || null;
        if (prevFp) {
          const fp = await fingerprintFile(entry.file);
          if (fp === prevFp) {
            unchanged += 1;
            keepPaths.push(entry.path);
          } else {
            changed += 1;
            const data = await entry.file.arrayBuffer();
            files.push({
              path: entry.path,
              data,
              mtime_ms: Number.isFinite(entry.file.lastModified) ? entry.file.lastModified : null,
              fingerprint_sha256: fp,
            });
          }
          continue;
        }

        // Fallback: if we don't have a fingerprint in the cache yet, be conservative and re-read once.
        changed += 1;
        const data = await entry.file.arrayBuffer();
        files.push({
          path: entry.path,
          data,
          mtime_ms: Number.isFinite(entry.file.lastModified) ? entry.file.lastModified : null,
          fingerprint_sha256: await fingerprintFile(entry.file),
        });
      }

      setStatus(
        `Updating index: ${unchanged} unchanged, ${changed} changed, ${added} new, ${removedCount} removed${skippedNote}...`
      );
      const transfer = files.map((f) => f.data);
      await callWorker(
        "updateSelective",
        { files, keepPaths },
        state.backend?.kind === "worker" ? transfer : undefined
      );
    }

    const statsResult = await callWorker("stats", {});
    const warningsResult = await callWorker("warnings", {});
    const filesResult = await callWorker("files", {});

    const idResult = await callWorker("indexId", {});
    state.indexId = idResult.indexId || null;
    state.files = filesResult.files || [];

    elements.indexId.textContent = state.indexId || "(unknown)";
    elements.chunkCount.textContent = statsResult.stats.total_chunks;
    elements.warningCount.textContent = warningsResult.warnings.length;
    renderWarnings(warningsResult.warnings);
    populateFileFilter();
    await updateOutlineSymbols();
    await populateSavedIndexes();
    state.indexLoaded = true;
    setStatus("Index ready.");
  } catch (error) {
    setStatus(`Ingestion failed: ${formatErrorForUi(error)}`);
  } finally {
    state.busy = false;
  }
}