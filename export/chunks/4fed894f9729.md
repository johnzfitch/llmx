---
chunk_index: 1198
ref: "4fed894f9729"
id: "4fed894f97296fbffc067ee01c28be0291515ee14434d6c32b22e669b2df6c3b"
slug: "hig-usability-tests-l141-292"
path: "/home/zack/dev/llmx/ingestor-core/tests/hig_usability_tests.rs"
kind: "text"
lines: [141, 292]
token_estimate: 1051
content_sha256: "6aacab5862572b37e8eecea7e5a5628c725701dbc53c19b1fb59b6d0ab41cc81"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

#[test]
fn test_hig_consistency_storage_dir_flag() {
    // --storage-dir should be consistent global flag
    llmx()
        .arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::contains("--storage-dir"));
}

#[test]
fn test_hig_consistency_subcommand_naming() {
    // Commands should use consistent verb naming
    let expected_commands = ["index", "search", "explore", "list", "delete", "export", "get"];

    let output = llmx().arg("--help").assert().success();

    let stdout = String::from_utf8_lossy(&output.get_output().stdout);
    for cmd in expected_commands {
        assert!(
            stdout.contains(cmd),
            "Help should list '{}' command",
            cmd
        );
    }
}

// ============================================================================
// HIG Principle: Clarity
// "Communicate clearly and avoid jargon"
// ============================================================================

#[test]
fn test_hig_clarity_error_no_index() {
    let storage = TempDir::new().unwrap();
    let empty_dir = TempDir::new().unwrap();

    // Error message should be clear and actionable
    llmx()
        .args([
            "search",
            "test",
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .current_dir(empty_dir.path())
        .assert()
        .failure()
        .stderr(predicate::str::contains("No index found"))
        .stderr(predicate::str::contains("llmx index")); // Suggests how to fix
}

#[test]
fn test_hig_clarity_error_invalid_mode() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();

    llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success();

    // Error should explain valid options
    llmx()
        .args([
            "explore",
            "invalid",
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .current_dir(project.path())
        .assert()
        .failure()
        .stderr(predicate::str::contains("Invalid mode"))
        .stderr(predicate::str::contains("files").or(predicate::str::contains("outline")));
}

#[test]
fn test_hig_clarity_help_is_helpful() {
    // Help should explain what the tool does
    llmx()
        .arg("--help")
        .assert()
        .success()
        .stdout(predicate::str::contains("index"))
        .stdout(predicate::str::contains("search"));

    // Subcommand help should explain arguments
    llmx()
        .args(["index", "--help"])
        .assert()
        .success()
        .stdout(predicate::str::contains("path"));
}

// ============================================================================
// HIG Principle: Forgiveness
// "Allow users to undo or recover from actions"
// ============================================================================

#[test]
fn test_hig_forgiveness_can_reindex() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();

    // Index once
    llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout(predicate::str::contains("Created"));

    // Re-index (update) should work
    llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout(predicate::str::contains("Updated"));
}

#[test]
fn test_hig_forgiveness_delete_nonexistent_is_graceful() {
    let storage = TempDir::new().unwrap();

    // Note: Current behavior is that delete succeeds even for nonexistent IDs
    // This is arguably more forgiving - no error if already gone
    llmx()
        .args([
            "delete",
            "nonexistent-id",
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success();
}