---
chunk_index: 1075
ref: "8ace38698b90"
id: "8ace38698b90b9dadd8f805b1d946429040d072086f2fb360f200c10ebddbe57"
slug: "mod-l287-428"
path: "/home/zack/dev/llmx/ingestor-core/src/handlers/mod.rs"
kind: "text"
lines: [287, 428]
token_estimate: 1023
content_sha256: "751c9cfbf676905f0c911ef27346aad62e7040193243e6bb39a603cd43bc21f2"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

Ok(ExploreOutput {
        total: items.len(),
        items,
    })
}

/// Handler for `llmx_manage` tool: List or delete indexes.
pub fn llmx_manage_handler(store: &mut IndexStore, input: ManageInput) -> Result<ManageOutput> {
    match input.action.as_str() {
        "list" => {
            let indexes = store.list()?;
            Ok(ManageOutput {
                success: true,
                indexes: Some(indexes),
                message: None,
            })
        }
        "delete" => {
            let index_id = input
                .index_id
                .context("index_id is required for delete action")?;
            store.delete(&index_id)?;
            Ok(ManageOutput {
                success: true,
                indexes: None,
                message: Some(format!("Index {} deleted successfully", index_id)),
            })
        }
        _ => anyhow::bail!(
            "Invalid action: {}. Use 'list' or 'delete'",
            input.action
        ),
    }
}

/// Handler for getting a single chunk by ID or ref.
///
/// Searches by:
/// 1. Exact chunk ID match
/// 2. Chunk ref match (from chunk_refs)
/// 3. ID prefix match (for short refs)
pub fn llmx_get_chunk_handler(
    store: &mut IndexStore,
    index_id: &str,
    chunk_id: &str,
) -> Result<Option<ChunkOutput>> {
    let index = store.load(index_id)?;

    // Try exact ID match
    let chunk = index.chunks.iter().find(|c| c.id == chunk_id);

    // Try ref match
    let chunk = chunk.or_else(|| {
        // Find chunk ID by ref
        let id_from_ref = index.chunk_refs.iter()
            .find(|(_, r)| r.as_str() == chunk_id)
            .map(|(id, _)| id.as_str());

        if let Some(id) = id_from_ref {
            index.chunks.iter().find(|c| c.id == id)
        } else {
            None
        }
    });

    // Try ID prefix match (for short refs like first 12 chars)
    let chunk = chunk.or_else(|| {
        index.chunks.iter().find(|c| c.id.starts_with(chunk_id))
    });

    Ok(chunk.map(|c| ChunkOutput {
        chunk_id: c.id.clone(),
        path: c.path.clone(),
        start_line: c.start_line,
        end_line: c.end_line,
        content: c.content.clone(),
        symbol: c.symbol.clone(),
        heading_path: c.heading_path.clone(),
        token_estimate: c.token_estimate,
    }))
}

// Helper functions

fn walk_directory(path: &Path, files: &mut Vec<FileInput>) -> Result<()> {
    for entry in fs::read_dir(path)? {
        let entry = entry?;
        let path = entry.path();

        // Skip hidden directories and common non-code directories
        if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
            if name.starts_with('.') || name == "node_modules" || name == "target" || name == "dist" || name == "build" {
                continue;
            }
        }

        if path.is_dir() {
            walk_directory(&path, files)?;
        } else if path.is_file() {
            read_file(&path, files)?;
        }
    }
    Ok(())
}

fn read_file(path: &Path, files: &mut Vec<FileInput>) -> Result<()> {
    if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
        if !ALLOWED_EXTENSIONS.contains(&ext) {
            return Ok(());
        }
    } else {
        return Ok(());
    }

    let data = fs::read(path)?;
    let metadata = fs::metadata(path)?;

    files.push(FileInput {
        path: path.to_string_lossy().to_string(),
        data,
        mtime_ms: metadata
            .modified()
            .ok()
            .and_then(|t| t.duration_since(std::time::UNIX_EPOCH).ok())
            .map(|d| d.as_millis() as u64),
        fingerprint_sha256: None,
    });

    Ok(())
}

fn parse_chunk_kind(s: &str) -> Option<crate::ChunkKind> {
    match s {
        "markdown" => Some(crate::ChunkKind::Markdown),
        "json" => Some(crate::ChunkKind::Json),
        "javascript" => Some(crate::ChunkKind::JavaScript),
        "html" => Some(crate::ChunkKind::Html),
        "text" => Some(crate::ChunkKind::Text),
        "image" => Some(crate::ChunkKind::Image),
        _ => None,
    }
}