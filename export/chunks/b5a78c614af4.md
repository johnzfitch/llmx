---
chunk_index: 1110
ref: "b5a78c614af4"
id: "b5a78c614af44af04aeeba6c12fcbe0a1cab891fe721e1d17bb609069537eabe"
slug: "filetype-tests-l242-346"
path: "/home/zack/dev/llmx/ingestor-core/tests/filetype_tests.rs"
kind: "text"
lines: [242, 346]
token_estimate: 1023
content_sha256: "2de50aeb1f9a72aa1d5daf5aaef98492ccfe36b262d398c2b397d9cf36412719"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

#[test]
fn test_filetype_sql() {
    let input = create_file("sql", "SELECT * FROM users WHERE active = true;");
    let index = ingest_files(vec![input], IngestOptions::default());
    assert!(!index.files.is_empty(), "SQL file should be indexed");
}

// ============================================================================
// Images (as assets)
// ============================================================================

// Note: Currently png, jpg, jpeg, gif, webp are mapped to Image.
// svg is an allowed extension but not mapped to Image.
#[test_case("png")]
#[test_case("jpg")]
#[test_case("jpeg")]
#[test_case("gif")]
#[test_case("webp")]
fn test_filetype_images(ext: &str) {
    let input = FileInput {
        path: format!("image.{}", ext),
        data: vec![0x89, 0x50, 0x4E, 0x47], // PNG magic bytes (works for testing)
        mtime_ms: None,
        fingerprint_sha256: None,
    };
    let index = ingest_files(vec![input], IngestOptions::default());
    assert!(!index.files.is_empty(), "Image .{} should be indexed as asset", ext);
    assert_eq!(index.files[0].kind, ChunkKind::Image);
}

// TODO: svg should probably be Image but is currently Unknown
#[test]
fn test_filetype_svg_is_indexed() {
    let input = FileInput {
        path: "image.svg".to_string(),
        data: b"<svg></svg>".to_vec(),
        mtime_ms: None,
        fingerprint_sha256: None,
    };
    let index = ingest_files(vec![input], IngestOptions::default());
    // SVG is indexed but as Unknown kind currently
    assert!(!index.files.is_empty(), "SVG should be indexed");
}

// ============================================================================
// Extension Handling
// ============================================================================

#[test]
fn test_filetype_unsupported_extension_indexed_as_unknown() {
    // Note: The ingest_files function processes FileInput directly.
    // The extension filtering happens at the handler level (walk_directory).
    // When FileInput is passed directly, it's processed regardless of extension.
    let input = FileInput {
        path: "file.xyz".to_string(),
        data: b"some content".to_vec(),
        mtime_ms: None,
        fingerprint_sha256: None,
    };
    let index = ingest_files(vec![input], IngestOptions::default());
    // At the ingest level, all files are processed (filtering is at handler level)
    assert_eq!(index.files.len(), 1, "File should be processed at ingest level");
    assert_eq!(index.files[0].kind, ChunkKind::Unknown);
}

#[test]
fn test_filetype_no_extension_indexed_as_unknown() {
    // Note: Same as above - filtering happens at handler level.
    let input = FileInput {
        path: "Makefile".to_string(),
        data: b"all: build".to_vec(),
        mtime_ms: None,
        fingerprint_sha256: None,
    };
    let index = ingest_files(vec![input], IngestOptions::default());
    // At the ingest level, all files are processed
    assert_eq!(index.files.len(), 1, "File should be processed at ingest level");
    assert_eq!(index.files[0].kind, ChunkKind::Unknown);
}

// ============================================================================
// Mixed Content Tests
// ============================================================================

#[test]
fn test_multiple_filetypes_together() {
    let inputs = vec![
        create_file("rs", "fn main() {}"),
        create_file("js", "function test() {}"),
        create_file("md", "# Title"),
        create_file("json", "{}"),
        create_file("py", "def test(): pass"),
    ];

    let index = ingest_files(inputs, IngestOptions::default());

    assert_eq!(index.files.len(), 5, "All 5 files should be indexed");

    // Verify each has correct kind
    let kinds: Vec<_> = index.files.iter().map(|f| (&f.path, f.kind)).collect();
    assert!(kinds.iter().any(|(p, k)| p.ends_with(".md") && *k == ChunkKind::Markdown));
    assert!(kinds.iter().any(|(p, k)| p.ends_with(".json") && *k == ChunkKind::Json));
    assert!(kinds.iter().any(|(p, k)| p.ends_with(".js") && *k == ChunkKind::JavaScript));
}