---
chunk_index: 1088
ref: "8fb6bacb6920"
id: "8fb6bacb692040c0d1ec5b273bc72b14d5e03cd8a2c4b5cf49e64be8768aca27"
slug: "tools-l1-113"
path: "/home/zack/dev/llmx/ingestor-core/src/mcp/tools.rs"
kind: "text"
lines: [1, 113]
token_estimate: 1009
content_sha256: "7fd704ebf01b5c1cf0fe5044616f2440499361610ba1e07166a3bdef17d81538"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

//! MCP tool input types with JsonSchema support.
//!
//! These types wrap the handler types to add JsonSchema derives for MCP protocol.
//! The actual handler logic is in the `handlers` module.

use serde::Deserialize;
use schemars::JsonSchema;

/// Input for llmx_index tool (with JsonSchema for MCP)
#[derive(Debug, Deserialize, JsonSchema)]
pub struct IndexInputMcp {
    #[schemars(description = "File or directory paths to index")]
    pub paths: Vec<String>,
    #[serde(default)]
    #[schemars(description = "Optional ingest configuration")]
    pub options: Option<IngestOptionsInputMcp>,
}

#[derive(Debug, Deserialize, Default, JsonSchema)]
pub struct IngestOptionsInputMcp {
    #[schemars(description = "Target chunk size in characters")]
    pub chunk_target_chars: Option<usize>,
    #[schemars(description = "Maximum file size in bytes")]
    pub max_file_bytes: Option<usize>,
}

/// Input for llmx_search tool (with JsonSchema for MCP)
#[derive(Debug, Deserialize, JsonSchema)]
pub struct SearchInputMcp {
    #[schemars(description = "Index ID to search")]
    pub index_id: String,
    #[schemars(description = "Search query")]
    pub query: String,
    #[serde(default)]
    #[schemars(description = "Optional search filters")]
    pub filters: Option<SearchFiltersInputMcp>,
    #[serde(default)]
    #[schemars(description = "Maximum number of results (default 10)")]
    pub limit: Option<usize>,
    #[serde(default)]
    #[schemars(description = "Token budget for inline content (default 16000)")]
    pub max_tokens: Option<usize>,
    #[serde(default)]
    #[schemars(description = "Enable semantic search with embeddings (default false)")]
    pub use_semantic: Option<bool>,
}

#[derive(Debug, Deserialize, Default, JsonSchema)]
pub struct SearchFiltersInputMcp {
    #[schemars(description = "Filter by file path prefix")]
    pub path_prefix: Option<String>,
    #[schemars(description = "Filter by chunk kind (markdown, javascript, json, html, text, image)")]
    pub kind: Option<String>,
    #[schemars(description = "Filter by symbol prefix")]
    pub symbol_prefix: Option<String>,
    #[schemars(description = "Filter by heading prefix")]
    pub heading_prefix: Option<String>,
}

/// Input for llmx_explore tool (with JsonSchema for MCP)
#[derive(Debug, Deserialize, JsonSchema)]
pub struct ExploreInputMcp {
    #[schemars(description = "Index ID to explore")]
    pub index_id: String,
    #[schemars(description = "What to list: 'files', 'outline', or 'symbols'")]
    pub mode: String,
    #[serde(default)]
    #[schemars(description = "Optional path prefix filter")]
    pub path_filter: Option<String>,
}

/// Input for llmx_manage tool (with JsonSchema for MCP)
#[derive(Debug, Deserialize, JsonSchema)]
pub struct ManageInputMcp {
    #[schemars(description = "Action: 'list' or 'delete'")]
    pub action: String,
    #[serde(default)]
    #[schemars(description = "Index ID (required for delete)")]
    pub index_id: Option<String>,
}

// Conversion from MCP types to handler types

impl From<IndexInputMcp> for crate::handlers::IndexInput {
    fn from(mcp: IndexInputMcp) -> Self {
        crate::handlers::IndexInput {
            paths: mcp.paths,
            options: mcp.options.map(|o| crate::handlers::IngestOptionsInput {
                chunk_target_chars: o.chunk_target_chars,
                max_file_bytes: o.max_file_bytes,
            }),
        }
    }
}

impl From<SearchInputMcp> for crate::handlers::SearchInput {
    fn from(mcp: SearchInputMcp) -> Self {
        crate::handlers::SearchInput {
            index_id: mcp.index_id,
            query: mcp.query,
            filters: mcp.filters.map(|f| crate::handlers::SearchFiltersInput {
                path_prefix: f.path_prefix,
                kind: f.kind,
                symbol_prefix: f.symbol_prefix,
                heading_prefix: f.heading_prefix,
            }),
            limit: mcp.limit,
            max_tokens: mcp.max_tokens,
            use_semantic: mcp.use_semantic,
        }
    }
}