---
chunk_index: 1193
ref: "eaf92390e976"
id: "eaf92390e976dfd610bda8e35d5b90b0fdb46a0ac5f92462bac1cb468be450c4"
slug: "handler-tests-l158-292"
path: "/home/zack/dev/llmx/ingestor-core/tests/handler_tests.rs"
kind: "text"
lines: [158, 292]
token_estimate: 1045
content_sha256: "7012c11fef0ac481c892177fb7b62c20173caaba7e0681b10c8745e4c1024ba0"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

#[test]
fn test_handler_index_empty_directory() {
    let (_storage, mut store) = create_store();
    let empty_dir = TempDir::new().expect("Failed to create temp dir");

    let input = IndexInput {
        paths: vec![empty_dir.path().to_string_lossy().to_string()],
        options: None,
    };

    let output = llmx_index_handler(&mut store, input).expect("Index should succeed");
    assert_eq!(output.stats.total_files, 0);
    assert_eq!(output.stats.total_chunks, 0);
}

// ============================================================================
// Search Handler Tests
// ============================================================================

#[test]
fn test_handler_search_finds_results() {
    let (_storage, mut store) = create_store();
    let project = create_test_project();

    // Index first
    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    // Search
    let search_input = SearchInput {
        index_id: idx_output.index_id,
        query: "fibonacci".to_string(),
        filters: None,
        limit: Some(10),
        max_tokens: Some(16000),
        use_semantic: None,
    };

    let output = llmx_search_handler(&mut store, search_input).expect("Search should succeed");
    assert!(output.total_matches > 0, "Should find fibonacci");
    assert!(!output.results.is_empty(), "Should have results");
}

#[test]
fn test_handler_search_with_path_filter() {
    let (_storage, mut store) = create_store();
    let project = create_test_project();

    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    // Search with path filter
    let search_input = SearchInput {
        index_id: idx_output.index_id,
        query: "function".to_string(),
        filters: Some(SearchFiltersInput {
            path_prefix: Some("src/".to_string()),
            kind: None,
            symbol_prefix: None,
            heading_prefix: None,
        }),
        limit: Some(10),
        max_tokens: Some(16000),
        use_semantic: None,
    };

    let output = llmx_search_handler(&mut store, search_input).expect("Search should succeed");
    // All results should be from src/
    for result in &output.results {
        assert!(
            result.path.contains("src/"),
            "Result {} should be in src/",
            result.path
        );
    }
}

#[test]
fn test_handler_search_token_budget_enforced() {
    let (_storage, mut store) = create_store();
    let project = create_test_project();

    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    // Search with very small token budget
    let search_input = SearchInput {
        index_id: idx_output.index_id.clone(),
        query: "fn".to_string(),
        filters: None,
        limit: Some(100),
        max_tokens: Some(100), // Very small budget
        use_semantic: None,
    };

    let output = llmx_search_handler(&mut store, search_input).expect("Search should succeed");

    // Should have truncated IDs if budget was exceeded
    if output.total_matches > output.results.len() {
        assert!(
            output.truncated_ids.is_some(),
            "Should have truncated IDs when budget exceeded"
        );
    }
}

#[test]
fn test_handler_search_no_results() {
    let (_storage, mut store) = create_store();
    let project = create_test_project();

    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    let search_input = SearchInput {
        index_id: idx_output.index_id,
        query: "xyznonexistentterm".to_string(),
        filters: None,
        limit: Some(10),
        max_tokens: Some(16000),
        use_semantic: None,
    };