---
chunk_index: 1256
ref: "1070f1f36cba"
id: "1070f1f36cba8f857e8666eff39f36ff8e0646c102a099c9088f776f535cf29b"
slug: "lib-l110-201"
path: "/home/zack/dev/llmx/ingestor-wasm/src/lib.rs"
kind: "text"
lines: [110, 201]
token_estimate: 716
content_sha256: "9b54ed5099d9eaa91c66eb2c45e99d30d4d6f55029ee0544dc04afc02faee27d"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

#[wasm_bindgen(js_name = stats)]
    pub fn stats(&self) -> Result<JsValue, JsValue> {
        to_value(&self.index.stats).map_err(to_js_error)
    }

    #[wasm_bindgen(js_name = files)]
    pub fn files(&self) -> Result<JsValue, JsValue> {
        to_value(&self.index.files).map_err(to_js_error)
    }
}

fn parse_options(value: JsValue) -> Result<IngestOptions, JsValue> {
    if value.is_null() || value.is_undefined() {
        Ok(IngestOptions::default())
    } else {
        from_value(value).map_err(to_js_error)
    }
}

fn to_js_error<E: std::fmt::Display>(error: E) -> JsValue {
    JsValue::from_str(&error.to_string())
}

fn export_zip_with_assets(index: &IndexFile, assets: &BTreeMap<String, Vec<u8>>) -> Vec<u8> {
    let buffer = Cursor::new(Vec::new());
    let mut writer = zip::ZipWriter::new(buffer);
    let options = FileOptions::default();

    let llm = export_llm(index);
    writer.start_file("llm.md", options).ok();
    writer.write_all(llm.as_bytes()).ok();

    let index_json = serde_json::to_string(index).unwrap_or_default();
    writer.start_file("index.json", options).ok();
    writer.write_all(index_json.as_bytes()).ok();

    let manifest = export_manifest_json(index);
    writer.start_file("manifest.json", options).ok();
    writer.write_all(manifest.as_bytes()).ok();

    for (name, content) in export_chunks(index) {
        writer.start_file(name, options).ok();
        writer.write_all(content.as_bytes()).ok();
    }

    for (path, bytes) in assets {
        writer.start_file(path, options).ok();
        writer.write_all(bytes).ok();
    }

    match writer.finish() {
        Ok(cursor) => cursor.into_inner(),
        Err(_) => Vec::new(),
    }
}

fn collect_assets(files: &[FileInput]) -> BTreeMap<String, Vec<u8>> {
    let mut out = BTreeMap::new();
    for file in files {
        if file.path.to_ascii_lowercase().ends_with(".png")
            || file.path.to_ascii_lowercase().ends_with(".jpg")
            || file.path.to_ascii_lowercase().ends_with(".jpeg")
            || file.path.to_ascii_lowercase().ends_with(".webp")
            || file.path.to_ascii_lowercase().ends_with(".gif")
            || file.path.to_ascii_lowercase().ends_with(".bmp")
        {
            out.insert(format!("images/{}", sanitize_zip_path(&file.path)), file.data.clone());
        }
    }
    out
}

fn merge_assets(out: &mut BTreeMap<String, Vec<u8>>, files: &[FileInput]) {
    for (path, bytes) in collect_assets(files) {
        out.insert(path, bytes);
    }
}

fn sanitize_zip_path(input: &str) -> String {
    let replaced = input.replace('\\', "/");
    let mut parts = Vec::new();
    for part in replaced.split('/') {
        if part.is_empty() || part == "." {
            continue;
        }
        if part == ".." {
            continue;
        }
        parts.push(part);
    }
    parts.join("/")
}