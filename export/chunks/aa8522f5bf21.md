---
chunk_index: 187
ref: "aa8522f5bf21"
id: "aa8522f5bf21d76b45769df6429e7973f521e6e2dd2766bc9807a7293bacf6d9"
slug: "cutting-edge-enhancements--implementation"
path: "/home/zack/dev/llmx/docs/CUTTING_EDGE_ENHANCEMENTS.md"
kind: "markdown"
lines: [209, 303]
token_estimate: 679
content_sha256: "9283ea4c0975c0950ce5c3ec5c04e0c49074cb23644ddfa54bd5778064efd1ac"
compacted: false
heading_path: ["Cutting-Edge Enhancements for Phases 1-4","3. Self-Tuning from Agent Behavior ðŸ§ ","Implementation"]
symbol: null
address: null
asset_path: null
---

### Implementation

**1. Track agent interactions**:
```rust
// New table in storage
pub struct AgentFeedback {
    pub query: String,
    pub clicked_chunks: Vec<String>,    // Chunks agent used
    pub completion_success: bool,       // Did agent complete task?
    pub timestamp: SystemTime,
}

// Collect feedback
pub fn record_feedback(
    &mut self,
    query: &str,
    results: &[ChunkResult],
    agent_actions: &AgentSession,
) {
    // Track which results were useful
    let clicked = results.iter()
        .filter(|r| agent_actions.used_chunk(&r.chunk_id))
        .map(|r| r.chunk_id.clone())
        .collect();
    
    self.feedback.push(AgentFeedback {
        query: query.to_string(),
        clicked_chunks: clicked,
        completion_success: agent_actions.task_completed,
        timestamp: SystemTime::now(),
    });
}
```

**2. Learn ranking adjustments**:
```rust
pub fn compute_learned_boost(&self, query: &str, chunk_id: &str) -> f32 {
    // Find similar past queries
    let similar = self.feedback.iter()
        .filter(|f| query_similarity(&f.query, query) > 0.7)
        .collect();
    
    // If this chunk was useful for similar queries, boost it
    let click_rate = similar.iter()
        .filter(|f| f.clicked_chunks.contains(&chunk_id))
        .count() as f32 / similar.len() as f32;
    
    // Success rate when this chunk was used
    let success_rate = similar.iter()
        .filter(|f| f.clicked_chunks.contains(&chunk_id) && f.completion_success)
        .count() as f32 / similar.len() as f32;
    
    // Learned boost (0.0 - 1.0)
    (click_rate * 0.5) + (success_rate * 0.5)
}
```

**3. Apply in ranking**:
```rust
pub fn search_with_learning(&self, query: &str) -> Vec<ChunkResult> {
    let bm25_results = self.bm25_search(query);
    
    // Re-rank with learned boosts
    let mut scored: Vec<_> = bm25_results.iter()
        .map(|(chunk_id, bm25_score)| {
            let learned_boost = self.compute_learned_boost(query, chunk_id);
            let final_score = (bm25_score * 0.7) + (learned_boost * 0.3);
            (chunk_id, final_score)
        })
        .collect();
    
    scored.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap());
    scored
}
```

**Why it's cutting edge**:
- **Personalized to agent behavior** (not generic ranking)
- **Improves over time** (more data = better ranking)
- **No manual tuning** (learns from usage)

**Privacy-preserving variant**:
```rust
// Don't store actual queries, only query embeddings
pub struct PrivateFeedback {
    pub query_embedding: Vec<f32>,     // 384D, not readable
    pub clicked_chunks: Vec<String>,
    pub success: bool,
}
```

**When to implement**: Phase 6 (after baseline established)

---