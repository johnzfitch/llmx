---
chunk_index: 1105
ref: "bb97775142d2"
id: "bb97775142d214dad2108848ede976ec375052d4ed2fc3549f7ae76456c2397f"
slug: "edge-cases-tests-l420-499"
path: "/home/zack/dev/llmx/ingestor-core/tests/edge_cases_tests.rs"
kind: "text"
lines: [420, 499]
token_estimate: 583
content_sha256: "8d9ec9344aa2e358f1fbf610c030ec6a6189e31cb75a189d135db70f2558b375"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

// ============================================================================
// Size Limit Edge Cases
// ============================================================================

#[test]
fn test_file_exactly_at_size_limit() {
    let options = IngestOptions {
        max_file_bytes: 100,
        ..IngestOptions::default()
    };

    // Exactly at limit
    let input = FileInput {
        path: "exact.rs".to_string(),
        data: vec![b'x'; 100],
        mtime_ms: None,
        fingerprint_sha256: None,
    };

    let index = ingest_files(vec![input], options);
    // Should be included (at limit, not over)
    assert_eq!(index.files.len(), 1);
}

#[test]
fn test_file_one_byte_over_limit() {
    let options = IngestOptions {
        max_file_bytes: 100,
        ..IngestOptions::default()
    };

    // One byte over limit
    let input = FileInput {
        path: "over.rs".to_string(),
        data: vec![b'x'; 101],
        mtime_ms: None,
        fingerprint_sha256: None,
    };

    let index = ingest_files(vec![input], options);
    // Should be excluded with warning
    assert!(index.files.is_empty());
    assert!(!index.warnings.is_empty());
}

// ============================================================================
// Concurrent Access Simulation
// ============================================================================

#[test]
fn test_multiple_indexes_same_store() {
    let (_storage, mut store) = create_store();

    // Create multiple projects
    let project1 = TempDir::new().unwrap();
    let project2 = TempDir::new().unwrap();

    fs::write(project1.path().join("a.rs"), "fn a() {}").unwrap();
    fs::write(project2.path().join("b.rs"), "fn b() {}").unwrap();

    // Index both
    let input1 = IndexInput {
        paths: vec![project1.path().to_string_lossy().to_string()],
        options: None,
    };
    let output1 = llmx_index_handler(&mut store, input1).unwrap();

    let input2 = IndexInput {
        paths: vec![project2.path().to_string_lossy().to_string()],
        options: None,
    };
    let output2 = llmx_index_handler(&mut store, input2).unwrap();

    // Both should succeed with different IDs
    assert_ne!(output1.index_id, output2.index_id);

    // List should show both
    let list = store.list().unwrap();
    assert_eq!(list.len(), 2);
}