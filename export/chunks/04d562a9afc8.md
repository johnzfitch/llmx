---
chunk_index: 1067
ref: "04d562a9afc8"
id: "04d562a9afc8ffc0cf8fb5bd0e7f8b20532792c0e050e41524b8afd5db6b64af"
slug: "chunk-l432-577"
path: "/home/zack/dev/llmx/ingestor-core/src/chunk.rs"
kind: "text"
lines: [432, 577]
token_estimate: 1013
content_sha256: "2f2f96c29619963de0338eed684581e2b5a767a940231a9f4855eb6eeff1ddef"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

fn chunk_javascript(path: &str, text: &str, options: &IngestOptions) -> Vec<ChunkDraft> {
    let _ = path;
    #[cfg(not(feature = "treesitter"))]
    {
        return chunk_text(text, options)
            .into_iter()
            .map(|draft| ChunkDraft { kind: ChunkKind::JavaScript, ..draft })
            .collect();
    }
    #[cfg(feature = "treesitter")]
    {
    let language = select_js_language(path);
    let mut parser = Parser::new();
    if parser.set_language(language).is_err() {
        return chunk_text(text, options)
            .into_iter()
            .map(|draft| ChunkDraft { kind: ChunkKind::JavaScript, ..draft })
            .collect();
    }

    let tree = match parser.parse(text, None) {
        Some(tree) => tree,
        None => {
            return chunk_text(text, options)
                .into_iter()
                .map(|draft| ChunkDraft { kind: ChunkKind::JavaScript, ..draft })
                .collect();
        }
    };

    let mut cursor = tree.root_node().walk();
    let mut drafts = Vec::new();
    for child in tree.root_node().children(&mut cursor) {
        if !is_js_symbol_node(child) {
            continue;
        }
        if let Some(draft) = draft_from_node(text, child, ChunkKind::JavaScript) {
            drafts.push(draft);
        }
    }

    if drafts.is_empty() {
        chunk_text(text, options)
            .into_iter()
            .map(|draft| ChunkDraft { kind: ChunkKind::JavaScript, ..draft })
            .collect()
    } else {
        drafts
    }
    }
}

#[cfg(feature = "treesitter")]
fn draft_from_node(text: &str, node: Node, kind: ChunkKind) -> Option<ChunkDraft> {
    let start = node.start_byte();
    let end = node.end_byte();
    let slice = text.get(start..end)?;
    let start_line = node.start_position().row + 1;
    let end_line = node.end_position().row + 1;
    let symbol = node
        .child_by_field_name("name")
        .and_then(|n| text.get(n.start_byte()..n.end_byte()))
        .map(|s| s.to_string());

    Some(ChunkDraft {
        kind,
        start_line,
        end_line,
        content: slice.trim().to_string(),
        heading_path: Vec::new(),
        symbol,
        address: None,
    })
}

#[cfg(feature = "treesitter")]
fn is_js_symbol_node(node: Node) -> bool {
    matches!(
        node.kind(),
        "function_declaration" | "class_declaration" | "method_definition"
    )
}

#[cfg(feature = "treesitter")]
fn select_js_language(path: &str) -> Language {
    if path.ends_with(".ts") {
        tree_sitter_typescript::language_typescript()
    } else if path.ends_with(".tsx") {
        tree_sitter_typescript::language_tsx()
    } else {
        tree_sitter_javascript::language()
    }
}

struct ChunkFlushParams {
    start_line: usize,
    end_line: usize,
    kind: ChunkKind,
    symbol: Option<String>,
    address: Option<String>,
}

fn flush_chunk(
    drafts: &mut Vec<ChunkDraft>,
    buf: &mut Vec<String>,
    heading_path: &[String],
    params: ChunkFlushParams,
) {
    if buf.is_empty() || params.end_line < params.start_line {
        return;
    }
    let content = buf.join("\n");
    drafts.push(ChunkDraft {
        kind: params.kind,
        start_line: params.start_line,
        end_line: params.end_line,
        content: content.trim().to_string(),
        heading_path: heading_path.to_vec(),
        symbol: params.symbol,
        address: params.address,
    });
    buf.clear();
}

fn buffer_len(buf: &[String]) -> usize {
    buf.iter().map(|line| line.len() + 1).sum()
}

fn line_count(text: &str) -> usize {
    text.lines().count().max(1)
}

fn make_slug(
    path: &str,
    kind: ChunkKind,
    heading_path: &[String],
    symbol: &Option<String>,
    address: &Option<String>,
    start_line: usize,
    end_line: usize,
) -> String {
    let base_name = path.rsplit('/').next().unwrap_or(path);
    let base_stem = strip_extension(base_name);
    let base_limit = if kind == ChunkKind::Image { 72 } else { 28 };
    let base_slug = truncate_slug(&slugify(base_stem), base_limit);