---
chunk_index: 201
ref: "23b7226b0fd6"
id: "23b7226b0fd662174013a9e56e709451c6654839cc289a20c7584d21f1826c24"
slug: "cutting-edge-enhancements--streaming-approach"
path: "/home/zack/dev/llmx/docs/CUTTING_EDGE_ENHANCEMENTS.md"
kind: "markdown"
lines: [626, 669]
token_estimate: 272
content_sha256: "dfb1426825256e4bf6e617f1fdb03917f46c98a79ed0d3dec1844403a2a836e6"
compacted: false
heading_path: ["Cutting-Edge Enhancements for Phases 1-4","7. Zero-Copy Streaming for Large Results ðŸš°","Streaming Approach"]
symbol: null
address: null
asset_path: null
---

### Streaming Approach
```rust
// Stream results as they're found
pub async fn search_streaming(
    &self,
    query: &str,
) -> impl Stream<Item = ChunkResult> {
    stream! {
        for (chunk_id, score) in self.bm25_search(query) {
            let chunk = self.get_chunk(chunk_id)?;
            yield ChunkResult {
                chunk_id,
                score,
                content: chunk.content,  // No accumulation
            };
        }
    }
}
```

**Benefits**:
- **Lower memory**: No intermediate buffer
- **Faster first result**: Agent sees results immediately
- **Backpressure**: Stop if agent has enough

**Implementation with MCP**:
```rust
// MCP server with streaming
#[tool(description = "Search with streaming results")]
async fn llmx_search_stream(
    &self,
    Parameters(input): Parameters<SearchInput>,
) -> impl Stream<Item = Result<ChunkResult, McpError>> {
    let store = self.store.lock().await;
    
    store.search_streaming(&input.query)
        .map(|r| Ok(r))
}
```

**When to implement**: Phase 6 (after MCP streaming support confirmed)

---