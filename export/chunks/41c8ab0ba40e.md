---
chunk_index: 341
ref: "41c8ab0ba40e"
id: "41c8ab0ba40e31651c742d5a274c06b5bdcccb7f319abb7adc7ffc4e347a6d3a"
slug: "phase6-blocker-fixes--if-all-else-fails-pivot-to-transformers-js"
path: "/home/zack/dev/llmx/docs/PHASE6_BLOCKER_FIXES.md"
kind: "markdown"
lines: [370, 386]
token_estimate: 158
content_sha256: "28d4e1e9f85a8f22d11fc6ea9210f2a2963cb749012867496bb59a4b241eb186"
compacted: false
heading_path: ["Phase 6 Blocker Resolution Guide","If All Else Fails: Pivot to Transformers.js"]
symbol: null
address: null
asset_path: null
---

## If All Else Fails: Pivot to Transformers.js

If Burn + WASM remains too painful, consider using Transformers.js directly:

```javascript
import { pipeline } from '@xenova/transformers';

const embedder = await pipeline('feature-extraction', 'Xenova/bge-small-en-v1.5', {
    device: 'webgpu'  // Uses WebGPU when available
});

const embedding = await embedder('text to embed', { pooling: 'mean', normalize: true });
```

This is battle-tested, but moves embedding logic to JS. Your Rust code would receive embeddings rather than generating them.

**Trade-off:** Less Rust purity, but guaranteed to work in browser with WebGPU.