---
chunk_index: 1062
ref: "6a3123068be2"
id: "6a3123068be2c20c6d16606d0cf6fe8a1cc097a159035e0187de07f561936531"
slug: "mcp-server-l1-107"
path: "/home/zack/dev/llmx/ingestor-core/src/bin/mcp_server.rs"
kind: "text"
lines: [1, 107]
token_estimate: 1017
content_sha256: "fd67b009b58e99f317c1679f3fe313ee70758fc8153bc446973a2ce3bdec4b3b"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

use ingestor_core::handlers::{
    llmx_explore_handler, llmx_index_handler, llmx_manage_handler, llmx_search_handler,
    IndexStore,
};
use ingestor_core::mcp::tools::{
    IndexInputMcp, SearchInputMcp, ExploreInputMcp, ManageInputMcp,
};
use rmcp::handler::server::{router::tool::ToolRouter, tool::Parameters};
use rmcp::model::{ErrorData as McpError, *};
use rmcp::{tool, tool_handler, tool_router, ServerHandler, ServiceExt};
use std::env;
use std::future::Future;
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use tracing_subscriber::EnvFilter;

/// MCP server for codebase indexing and semantic search.
///
/// Provides four tools:
/// - `llmx_index`: Create/update codebase indexes from file paths
/// - `llmx_search`: Search with token-budgeted inline content (default 16K tokens)
/// - `llmx_explore`: List files, outline headings, or symbols in an index
/// - `llmx_manage`: List or delete indexes
///
/// # Architecture
///
/// The server uses an `IndexStore` to manage persistent indexes on disk with an
/// in-memory cache for performance. All indexes are stored in `~/.llmx/indexes/`
/// by default (configurable via `LLMX_STORAGE_DIR`).
///
/// # Thread Safety
///
/// The `IndexStore` is wrapped in `Arc<Mutex<>>` to enable shared access across
/// async tasks while maintaining interior mutability for the cache.
#[derive(Clone)]
struct LlmxServer {
    store: Arc<Mutex<IndexStore>>,
    tool_router: ToolRouter<Self>,
}

#[tool_router]
impl LlmxServer {
    fn new(store: Arc<Mutex<IndexStore>>) -> Self {
        Self {
            store,
            tool_router: Self::tool_router(),
        }
    }

    /// Create or update a codebase index from file paths
    #[tool(description = "Create or update index from file paths")]
    async fn llmx_index(
        &self,
        Parameters(input): Parameters<IndexInputMcp>,
    ) -> Result<CallToolResult, McpError> {
        let mut store = self.store.lock().unwrap();
        let output = llmx_index_handler(&mut store, input.into())
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let content = serde_json::to_string_pretty(&output)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(content)]))
    }

    /// Search indexed codebase with inline content (token-budgeted)
    #[tool(description = "Search index with inline content")]
    async fn llmx_search(
        &self,
        Parameters(input): Parameters<SearchInputMcp>,
    ) -> Result<CallToolResult, McpError> {
        let mut store = self.store.lock().unwrap();
        let output = llmx_search_handler(&mut store, input.into())
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let content = serde_json::to_string_pretty(&output)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(content)]))
    }

    /// Explore index structure: files, outline, or symbols
    #[tool(description = "Explore index structure: files, outline, symbols")]
    async fn llmx_explore(
        &self,
        Parameters(input): Parameters<ExploreInputMcp>,
    ) -> Result<CallToolResult, McpError> {
        let mut store = self.store.lock().unwrap();
        let output = llmx_explore_handler(&mut store, input.into())
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        let content = serde_json::to_string_pretty(&output)
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;

        Ok(CallToolResult::success(vec![Content::text(content)]))
    }

    /// List or delete indexes
    #[tool(description = "List or delete indexes")]
    async fn llmx_manage(
        &self,
        Parameters(input): Parameters<ManageInputMcp>,
    ) -> Result<CallToolResult, McpError> {
        let mut store = self.store.lock().unwrap();
        let output = llmx_manage_handler(&mut store, input.into())
            .map_err(|e| McpError::internal_error(e.to_string(), None))?;