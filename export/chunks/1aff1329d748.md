---
chunk_index: 1074
ref: "1aff1329d748"
id: "1aff1329d74812d24a5e991effca5a4dd371c52e51b9cad1c6f7d3b4b25e9155"
slug: "mod-l147-286"
path: "/home/zack/dev/llmx/ingestor-core/src/handlers/mod.rs"
kind: "text"
lines: [147, 286]
token_estimate: 1117
content_sha256: "944177a384853aafe59bf8f04ce3e59606cfe7c7108a96bae92e4e77077095aa"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

let limit = input.limit.unwrap_or(10);
    let max_tokens = input.max_tokens.unwrap_or(DEFAULT_MAX_TOKENS);

    let search_results = if input.use_semantic.unwrap_or(false) {
        #[cfg(feature = "embeddings")]
        {
            use crate::embeddings::generate_embedding;
            use crate::index::hybrid_search;

            if let Some(embeddings) = &index.embeddings {
                let query_embedding = generate_embedding(&input.query);
                hybrid_search(
                    &index.chunks,
                    &index.inverted_index,
                    &index.chunk_refs,
                    embeddings,
                    &input.query,
                    &query_embedding,
                    &filters,
                    limit * 2,
                )
            } else {
                search(index, &input.query, filters.clone(), limit * 2)
            }
        }
        #[cfg(not(feature = "embeddings"))]
        {
            search(index, &input.query, filters.clone(), limit * 2)
        }
    } else {
        search(index, &input.query, filters, limit * 2)
    };

    let mut results = vec![];
    let mut tokens_used = 0;
    let mut truncated = vec![];

    for result in &search_results {
        let chunk = index
            .chunks
            .iter()
            .find(|c| c.id == result.chunk_id)
            .context("Chunk not found")?;

        if tokens_used + chunk.token_estimate <= max_tokens {
            results.push(SearchResultOutput {
                chunk_id: result.chunk_id.clone(),
                score: result.score,
                path: result.path.clone(),
                start_line: result.start_line,
                end_line: result.end_line,
                content: chunk.content.clone(),
                symbol: chunk.symbol.clone(),
                heading_path: result.heading_path.clone(),
            });
            tokens_used += chunk.token_estimate;
        } else {
            truncated.push(result.chunk_id.clone());
        }

        if results.len() >= limit {
            break;
        }
    }

    Ok(SearchOutput {
        results,
        truncated_ids: if truncated.is_empty() {
            None
        } else {
            Some(truncated)
        },
        total_matches: search_results.len(),
    })
}

/// Handler for `llmx_explore` tool: Explore index structure.
///
/// Modes:
/// - `files`: List all indexed file paths
/// - `outline`: List all heading paths
/// - `symbols`: List all symbol names
pub fn llmx_explore_handler(store: &mut IndexStore, input: ExploreInput) -> Result<ExploreOutput> {
    let index = store.load(&input.index_id)?;

    let items: Vec<String> = match input.mode.as_str() {
        "files" => {
            let mut files: Vec<_> = index
                .files
                .iter()
                .filter(|f| {
                    if let Some(ref prefix) = input.path_filter {
                        f.path.starts_with(prefix)
                    } else {
                        true
                    }
                })
                .map(|f| f.path.clone())
                .collect();
            files.sort();
            files
        }
        "outline" => {
            let mut headings = HashSet::new();
            for chunk in &index.chunks {
                if let Some(ref prefix) = input.path_filter {
                    if !chunk.path.starts_with(prefix) {
                        continue;
                    }
                }
                for heading in &chunk.heading_path {
                    headings.insert(heading.clone());
                }
            }
            let mut result: Vec<_> = headings.into_iter().collect();
            result.sort();
            result
        }
        "symbols" => {
            let mut symbols = HashSet::new();
            for chunk in &index.chunks {
                if let Some(ref prefix) = input.path_filter {
                    if !chunk.path.starts_with(prefix) {
                        continue;
                    }
                }
                if let Some(ref symbol) = chunk.symbol {
                    symbols.insert(symbol.clone());
                }
            }
            let mut result: Vec<_> = symbols.into_iter().collect();
            result.sort();
            result
        }
        _ => anyhow::bail!(
            "Invalid mode: {}. Use 'files', 'outline', or 'symbols'",
            input.mode
        ),
    };