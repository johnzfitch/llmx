---
chunk_index: 1204
ref: "7fe4c6f382b6"
id: "7fe4c6f382b61c61d8f6dc5920bc818a41c1496ad1ca338eb8378ef0a70ba9fe"
slug: "smoke-tests-l1-129"
path: "/home/zack/dev/llmx/ingestor-core/tests/smoke_tests.rs"
kind: "text"
lines: [1, 129]
token_estimate: 1012
content_sha256: "25acaa8d15be51f34021c9005bae084eedf9300700d826751fc59914cea04781"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

//! Smoke tests - quick validation of core functionality.
//!
//! These tests verify the basic happy paths work correctly.
//! They should complete quickly (<5 seconds total) and catch obvious regressions.
//!
//! Run with: cargo test --features cli --test smoke_tests

#![cfg(feature = "cli")]

mod common;

use ingestor_core::handlers::{
    llmx_explore_handler, llmx_get_chunk_handler, llmx_index_handler, llmx_manage_handler,
    llmx_search_handler, ExploreInput, IndexInput, IndexStore, ManageInput, SearchInput,
};
use ingestor_core::{export_llm, export_zip};
use tempfile::TempDir;
use std::fs;

/// Create a minimal test project for smoke tests.
fn create_minimal_project() -> TempDir {
    let temp = TempDir::new().expect("Failed to create temp dir");

    fs::write(
        temp.path().join("main.rs"),
        "fn main() { println!(\"Hello\"); }",
    )
    .unwrap();

    fs::write(
        temp.path().join("lib.rs"),
        "pub fn greet(name: &str) -> String { format!(\"Hello, {}\", name) }",
    )
    .unwrap();

    fs::write(
        temp.path().join("README.md"),
        "# Test\n\nA test project.\n\n## Usage\n\nRun `cargo run`.",
    )
    .unwrap();

    temp
}

#[test]
fn smoke_index_search_export() {
    // 1. Create temp storage and project
    let storage_temp = TempDir::new().unwrap();
    let mut store = IndexStore::new(storage_temp.path().to_path_buf()).unwrap();
    let project = create_minimal_project();

    // 2. Index the project
    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).expect("Index should succeed");

    assert!(idx_output.created);
    assert!(idx_output.stats.total_files >= 3);
    assert!(idx_output.stats.total_chunks >= 3);

    // 3. Search the index
    let search_input = SearchInput {
        index_id: idx_output.index_id.clone(),
        query: "greet".to_string(),
        filters: None,
        limit: Some(10),
        max_tokens: Some(16000),
        use_semantic: None,
    };
    let search_output = llmx_search_handler(&mut store, search_input).expect("Search should succeed");

    assert!(search_output.total_matches > 0);
    assert!(!search_output.results.is_empty());

    // 4. Export to llm.md format
    let index = store.load(&idx_output.index_id).unwrap();
    let llm_md = export_llm(index);

    assert!(!llm_md.is_empty());
    assert!(llm_md.contains("# "));
}

#[test]
fn smoke_full_workflow() {
    // Setup
    let storage_temp = TempDir::new().unwrap();
    let mut store = IndexStore::new(storage_temp.path().to_path_buf()).unwrap();
    let project = create_minimal_project();

    // 1. Index
    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).expect("1. Index should succeed");
    let index_id = idx_output.index_id.clone();

    // 2. List indexes
    let list_input = ManageInput {
        action: "list".to_string(),
        index_id: None,
    };
    let list_output = llmx_manage_handler(&mut store, list_input).expect("2. List should succeed");
    assert!(list_output.success);
    assert_eq!(list_output.indexes.as_ref().unwrap().len(), 1);

    // 3. Search
    let search_input = SearchInput {
        index_id: index_id.clone(),
        query: "fn".to_string(),
        filters: None,
        limit: Some(5),
        max_tokens: Some(8000),
        use_semantic: None,
    };
    let search_output = llmx_search_handler(&mut store, search_input).expect("3. Search should succeed");
    assert!(search_output.total_matches > 0);

    // 4. Explore files
    let explore_files = ExploreInput {
        index_id: index_id.clone(),
        mode: "files".to_string(),
        path_filter: None,
    };
    let files_output = llmx_explore_handler(&mut store, explore_files).expect("4. Explore files should succeed");
    assert!(files_output.total >= 3);