---
chunk_index: 1197
ref: "11729da71b18"
id: "11729da71b180509966c85afb7ee690d0fee21ff8bc21af04c99b7103fae33d1"
slug: "hig-usability-tests-l1-140"
path: "/home/zack/dev/llmx/ingestor-core/tests/hig_usability_tests.rs"
kind: "text"
lines: [1, 140]
token_estimate: 1002
content_sha256: "1938ed49694ec8b18b77d3d91ff2373239f94199cc451d115ba6bb034e69035b"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

//! HIG Usability Evaluation Tests
//!
//! These tests apply Apple Human Interface Guidelines principles to evaluate
//! the CLI user experience. Based on the Macintosh Human Interface Guidelines.
//!
//! Run with: cargo test --features cli --test hig_usability_tests

#![cfg(feature = "cli")]

use assert_cmd::Command;
use predicates::prelude::*;
use std::fs;
use tempfile::TempDir;

/// Get a Command for the llmx binary.
fn llmx() -> Command {
    Command::cargo_bin("llmx").expect("Failed to find llmx binary")
}

/// Create a test project.
fn create_test_project() -> TempDir {
    let temp = TempDir::new().expect("Failed to create temp dir");
    fs::write(
        temp.path().join("main.rs"),
        "fn main() { println!(\"Hello\"); }",
    )
    .unwrap();
    fs::write(temp.path().join("lib.rs"), "pub fn greet() {}").unwrap();
    fs::write(temp.path().join("README.md"), "# Project\n\nDescription").unwrap();
    temp
}

// ============================================================================
// HIG Principle: Feedback
// "Keep users informed about what's happening"
// ============================================================================

#[test]
fn test_hig_feedback_index_reports_progress() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();

    // Index should report what it did
    llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout(predicate::str::contains("index"))
        .stdout(predicate::str::contains("files"))
        .stdout(predicate::str::contains("chunks"));
}

#[test]
fn test_hig_feedback_search_reports_count() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();

    llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success();

    // Search should report result count
    llmx()
        .args([
            "search",
            "fn",
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .current_dir(project.path())
        .assert()
        .success()
        .stdout(predicate::str::contains("Found"))
        .stdout(predicate::str::contains("results"));
}

#[test]
fn test_hig_feedback_delete_confirms_action() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();

    // Index first
    let output = llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
            "--json",
        ])
        .assert()
        .success();

    let stdout = String::from_utf8_lossy(&output.get_output().stdout);
    let json: serde_json::Value = serde_json::from_str(&stdout).unwrap();
    let index_id = json["index_id"].as_str().unwrap();

    // Delete should confirm what was deleted
    llmx()
        .args([
            "delete",
            index_id,
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout(predicate::str::contains("deleted"));
}

// ============================================================================
// HIG Principle: Consistency
// "Use consistent terminology and interactions"
// ============================================================================

#[test]
fn test_hig_consistency_json_flag_everywhere() {
    // All commands should support --json consistently
    let commands_with_output = ["list", "index", "search", "explore", "export"];

    for cmd in commands_with_output {
        llmx()
            .args([cmd, "--help"])
            .assert()
            .success()
            .stdout(predicate::str::contains("--json"));
    }
}