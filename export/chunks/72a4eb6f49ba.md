---
chunk_index: 1059
ref: "72a4eb6f49ba"
id: "72a4eb6f49baaa9bd89d5ae2ee4a9049a7e3bb80d72e26ef53afe45fedb786f9"
slug: "llmx-l158-296"
path: "/home/zack/dev/llmx/ingestor-core/src/bin/llmx.rs"
kind: "text"
lines: [158, 296]
token_estimate: 1000
content_sha256: "a0ad62f6b6dab11c0b7e4d6dd5ef727051f32085e967229cba38461c9c652a59"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

Commands::Explore { mode, path } => {
            cmd_explore(&mut store, &cli.index_id, mode, path, cli.json)
        }

        Commands::List => cmd_list(&mut store, cli.json),

        Commands::Delete { id } => cmd_delete(&mut store, id, cli.json),

        Commands::Export { id, format, output } => {
            cmd_export(&mut store, &cli.index_id, id, format, output, cli.json)
        }

        Commands::Get { chunk_id } => cmd_get(&mut store, &cli.index_id, chunk_id, cli.json),
    }
}

fn cmd_index(
    store: &mut IndexStore,
    paths: Vec<PathBuf>,
    chunk_size: usize,
    max_file: usize,
    json_output: bool,
) -> Result<()> {
    let start = Instant::now();

    let path_strings: Vec<String> = paths
        .iter()
        .map(|p| {
            p.canonicalize()
                .unwrap_or_else(|_| p.clone())
                .to_string_lossy()
                .to_string()
        })
        .collect();

    let input = IndexInput {
        paths: path_strings,
        options: Some(IngestOptionsInput {
            chunk_target_chars: Some(chunk_size),
            max_file_bytes: Some(max_file),
        }),
    };

    let output = llmx_index_handler(store, input)?;
    let elapsed = start.elapsed();

    if json_output {
        println!("{}", serde_json::to_string_pretty(&output)?);
    } else {
        if output.created {
            println!("Created new index: {}", output.index_id);
        } else {
            println!("Updated index: {}", output.index_id);
        }
        println!(
            "  {} files, {} chunks (avg {} tokens/chunk)",
            output.stats.total_files, output.stats.total_chunks, output.stats.avg_chunk_tokens
        );
        println!("  Completed in {:.1}ms", elapsed.as_secs_f64() * 1000.0);

        if !output.warnings.is_empty() {
            println!("\nWarnings:");
            for w in &output.warnings {
                println!("  - {} ({}): {}", w.path, w.code, w.message);
            }
        }
    }

    Ok(())
}

fn cmd_search(
    store: &mut IndexStore,
    index_id_override: &Option<String>,
    query: String,
    max_tokens: usize,
    limit: usize,
    path: Option<String>,
    kind: Option<String>,
    semantic: bool,
    json_output: bool,
) -> Result<()> {
    let start = Instant::now();
    let index_id = resolve_index_id(store, index_id_override)?;

    let input = SearchInput {
        index_id,
        query: query.clone(),
        filters: Some(SearchFiltersInput {
            path_prefix: path,
            kind,
            symbol_prefix: None,
            heading_prefix: None,
        }),
        limit: Some(limit),
        max_tokens: Some(max_tokens),
        use_semantic: Some(semantic),
    };

    let output = llmx_search_handler(store, input)?;
    let elapsed = start.elapsed();

    if json_output {
        println!("{}", serde_json::to_string_pretty(&output)?);
    } else {
        println!(
            "Found {} results in {:.1}ms\n",
            output.total_matches,
            elapsed.as_secs_f64() * 1000.0
        );

        for (i, result) in output.results.iter().enumerate() {
            println!(
                "[{}] {}:{}-{} (score: {:.2})",
                i + 1,
                result.path,
                result.start_line,
                result.end_line,
                result.score
            );

            if let Some(ref sym) = result.symbol {
                println!("    Symbol: {}", sym);
            }
            if !result.heading_path.is_empty() {
                println!("    Heading: {}", result.heading_path.join(" > "));
            }

            println!("    ───────────────────────────────────");
            for line in result.content.lines().take(10) {
                println!("    {}", line);
            }
            if result.content.lines().count() > 10 {
                println!("    ...");
            }
            println!("    ───────────────────────────────────");
            println!();
        }