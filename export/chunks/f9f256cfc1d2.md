---
chunk_index: 1070
ref: "f9f256cfc1d2"
id: "f9f256cfc1d23f50470c8d265bd4c8a091368adacc501d440ef90069b6f2d072"
slug: "export-l1-121"
path: "/home/zack/dev/llmx/ingestor-core/src/export.rs"
kind: "text"
lines: [1, 121]
token_estimate: 1009
content_sha256: "1c35a7e1db13556d13132ffc6f1381b05fe63a0558a7f7e4017cd32a1ba10416"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

use crate::model::{Chunk, ChunkKind, FileMeta, IndexFile};
use crate::util::build_chunk_refs;
use serde::Serialize;
use std::cmp::Ordering;
use std::collections::BTreeMap;
use std::io::{Cursor, Write};
use zip::write::FileOptions;

pub fn export_llm(index: &IndexFile) -> String {
    let mut out = String::new();
    let mut chunks = index.chunks.clone();
    chunks.sort_by(chunk_sort);

    let file_meta = build_file_meta_map(&index.files);
    let refs = if index.chunk_refs.is_empty() {
        build_chunk_refs(&chunks)
    } else {
        index.chunk_refs.clone()
    };

    out.push_str("# llm.md (pointer manifest)\n\n");
    out.push_str("Index ID: ");
    out.push_str(&index.index_id);
    out.push_str("\nFiles: ");
    out.push_str(&index.files.len().to_string());
    out.push_str("  Chunks: ");
    out.push_str(&chunks.len().to_string());
    out.push_str("\n\n");
    out.push_str("Chunk files live under `chunks/` and are named `{ref}.md`.\n");
    out.push_str("Prefer search to find refs, then open only the referenced chunk files.\n\n");

    if !index.warnings.is_empty() {
        out.push_str("## Warnings\n\n");
        out.push_str("Some files were skipped or truncated.\n\n");
        for warning in &index.warnings {
            out.push_str(&format!(
                "- {}: {}\n",
                markdown_code_span(&warning.path),
                sanitize_single_line(&warning.message)
            ));
        }
        out.push('\n');
    }

    out.push_str("## Files\n\n");

    let mut current_path = String::new();
    for chunk in &chunks {
        if chunk.path != current_path {
            current_path = chunk.path.clone();
            if let Some(meta) = file_meta.get(current_path.as_str()) {
                let kind_short = kind_short_label(meta.kind);
                out.push_str(&format!(
                    "### {} ({}, {} lines)\n",
                    &current_path, kind_short, meta.line_count
                ));
            } else {
                out.push_str(&format!("### {}\n", &current_path));
            }
        }

        let chunk_ref = refs.get(chunk.id.as_str()).map(String::as_str).unwrap_or(&chunk.short_id);
        out.push_str(&render_chunk_entry_outline(chunk, chunk_ref));
        out.push('\n');
    }

    out
}

pub fn export_chunks(index: &IndexFile) -> Vec<(String, String)> {
    let mut chunks = index.chunks.clone();
    chunks.sort_by(chunk_sort);
    let refs = if index.chunk_refs.is_empty() {
        build_chunk_refs(&chunks)
    } else {
        index.chunk_refs.clone()
    };
    chunks
        .into_iter()
        .enumerate()
        .map(|(idx, chunk)| {
            let mut body = String::new();
            let (content, compacted) = compact_for_export(&chunk);
            let chunk_ref = refs.get(chunk.id.as_str()).map(String::as_str).unwrap_or(&chunk.short_id);
            body.push_str(&chunk_front_matter(idx + 1, &chunk, compacted, chunk_ref));
            body.push_str("\n\n");
            body.push_str(&content);
            let name = format!("chunks/{}.md", chunk_ref);
            (name, body)
        })
        .collect()
}

pub fn export_zip(index: &IndexFile) -> Vec<u8> {
    let buffer = Cursor::new(Vec::new());
    let mut writer = zip::ZipWriter::new(buffer);
    let options = FileOptions::default();

    let llm = export_llm(index);
    writer.start_file("llm.md", options).ok();
    writer.write_all(llm.as_bytes()).ok();

    let index_json = serde_json::to_string(index).unwrap_or_default();
    writer.start_file("index.json", options).ok();
    writer.write_all(index_json.as_bytes()).ok();

    let manifest = export_manifest(index);
    writer.start_file("manifest.json", options).ok();
    writer.write_all(manifest.as_bytes()).ok();

    for (name, content) in export_chunks(index) {
        writer.start_file(name, options).ok();
        writer.write_all(content.as_bytes()).ok();
    }

    match writer.finish() {
        Ok(cursor) => cursor.into_inner(),
        Err(_) => Vec::new(),
    }
}