---
chunk_index: 1072
ref: "1d6c7375ceff"
id: "1d6c7375cefff64bf1b343a868ed600b02180e7e98785b920ff2d0c01c44ca82"
slug: "export-l267-410"
path: "/home/zack/dev/llmx/ingestor-core/src/export.rs"
kind: "text"
lines: [267, 410]
token_estimate: 1057
content_sha256: "4f9ca6f18366487aec5f2d82f59748cfb2d8f4ad0292aa60cdc5bd191697f8ff"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

fn chunk_sort(a: &Chunk, b: &Chunk) -> Ordering {
    match a.path.cmp(&b.path) {
        Ordering::Equal => a.start_line.cmp(&b.start_line),
        other => other,
    }
}

fn compact_for_export(chunk: &Chunk) -> (String, bool) {
    if chunk.kind != ChunkKind::Text {
        return (chunk.content.clone(), false);
    }
    compact_repeated_lines(&chunk.content, 3)
}

fn compact_repeated_lines(text: &str, min_repeat: usize) -> (String, bool) {
    let mut out: Vec<String> = Vec::new();
    let mut current: Option<String> = None;
    let mut count = 0usize;
    let mut compacted = false;

    for line in text.lines() {
        match &current {
            Some(prev) if prev == line => {
                count += 1;
            }
            Some(prev) => {
                push_run(&mut out, prev, count, min_repeat, &mut compacted);
                current = Some(line.to_string());
                count = 1;
            }
            None => {
                current = Some(line.to_string());
                count = 1;
            }
        }
    }
    if let Some(prev) = current {
        push_run(&mut out, &prev, count, min_repeat, &mut compacted);
    }

    (out.join("\n"), compacted)
}

fn push_run(out: &mut Vec<String>, line: &str, count: usize, min_repeat: usize, compacted: &mut bool) {
    if count >= min_repeat {
        out.push(line.to_string());
        out.push(format!(
            "... (previous line repeated {} more times)",
            count.saturating_sub(1)
        ));
        *compacted = true;
    } else {
        for _ in 0..count {
            out.push(line.to_string());
        }
    }
}

fn yaml_string(value: &str) -> String {
    serde_json::to_string(value).unwrap_or_else(|_| "\"\"".to_string())
}

fn kind_label(kind: ChunkKind) -> &'static str {
    match kind {
        ChunkKind::Markdown => "markdown",
        ChunkKind::Json => "json",
        ChunkKind::JavaScript => "java_script",
        ChunkKind::Html => "html",
        ChunkKind::Text => "text",
        ChunkKind::Image => "image",
        ChunkKind::Unknown => "unknown",
    }
}

fn kind_short_label(kind: ChunkKind) -> &'static str {
    match kind {
        ChunkKind::Markdown => "md",
        ChunkKind::Json => "json",
        ChunkKind::JavaScript => "js",
        ChunkKind::Html => "html",
        ChunkKind::Text => "txt",
        ChunkKind::Image => "img",
        ChunkKind::Unknown => "?",
    }
}

fn build_file_meta_map(files: &[FileMeta]) -> BTreeMap<&str, &FileMeta> {
    let mut map = BTreeMap::new();
    for meta in files {
        map.insert(meta.path.as_str(), meta);
    }
    map
}

fn render_chunk_entry_outline(chunk: &Chunk, chunk_ref: &str) -> String {
    let lines = format!("{}-{}", chunk.start_line, chunk.end_line);

    // Build semantic label based on content type
    let semantic = match (chunk.kind, &chunk.symbol, chunk.heading_path.is_empty()) {
        // Code with symbol: show as function/class
        (ChunkKind::JavaScript, Some(sym), _) => format!("`{}()`", sym),
        // Markdown with headings: show breadcrumb path
        (ChunkKind::Markdown, _, false) => {
            chunk.heading_path.iter().rev().take(3).rev()
                .cloned().collect::<Vec<_>>().join(" > ")
        }
        // Fallback to slug
        _ => chunk.slug.clone(),
    };

    format!("- {} ({}) {}", chunk_ref, lines, semantic)
}

fn sanitize_single_line(input: &str) -> String {
    input
        .chars()
        .map(|ch| if ch == '\n' || ch == '\r' || ch.is_control() { ' ' } else { ch })
        .collect()
}

fn markdown_code_span(input: &str) -> String {
    let cleaned = sanitize_single_line(input);
    let fence_len = max_backtick_run(&cleaned) + 1;
    let fence = "`".repeat(fence_len);
    if cleaned.starts_with(' ') || cleaned.ends_with(' ') {
        format!("{fence} {cleaned} {fence}")
    } else {
        format!("{fence}{cleaned}{fence}")
    }
}

fn max_backtick_run(input: &str) -> usize {
    let mut max_run = 0usize;
    let mut current = 0usize;
    for ch in input.chars() {
        if ch == '`' {
            current += 1;
            max_run = max_run.max(current);
        } else {
            current = 0;
        }
    }
    max_run
}