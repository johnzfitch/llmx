---
chunk_index: 1102
ref: "8bb5f3a397f4"
id: "8bb5f3a397f4014e99d12c3aaef1154375049983b7e55bf78bbd487f40fdf34b"
slug: "edge-cases-tests-l1-136"
path: "/home/zack/dev/llmx/ingestor-core/tests/edge_cases_tests.rs"
kind: "text"
lines: [1, 136]
token_estimate: 1042
content_sha256: "264a4c016cc3b83e9f2cc9bd44d4b29cb2086e30cc90762f951cae105196230f"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

//! Edge case tests - verify graceful handling of unusual inputs.
//!
//! These tests cover boundary conditions, error handling, and unusual inputs.
//!
//! Run with: cargo test --features cli --test edge_cases_tests

#![cfg(feature = "cli")]

mod common;

use ingestor_core::handlers::{
    llmx_index_handler, llmx_search_handler, IndexInput, IndexStore, SearchInput,
};
use ingestor_core::{ingest_files, FileInput, IngestOptions};
use std::fs;
use tempfile::TempDir;

/// Create a fresh IndexStore with temp directory.
fn create_store() -> (TempDir, IndexStore) {
    let temp = TempDir::new().expect("Failed to create temp dir");
    let store = IndexStore::new(temp.path().to_path_buf()).expect("Failed to create store");
    (temp, store)
}

// ============================================================================
// File System Edge Cases
// ============================================================================

#[test]
fn test_empty_directory() {
    let (_storage, mut store) = create_store();
    let empty_dir = TempDir::new().unwrap();

    let input = IndexInput {
        paths: vec![empty_dir.path().to_string_lossy().to_string()],
        options: None,
    };

    let output = llmx_index_handler(&mut store, input).expect("Should handle empty dir");
    assert_eq!(output.stats.total_files, 0);
    assert_eq!(output.stats.total_chunks, 0);
}

#[test]
fn test_deeply_nested_paths() {
    let (_storage, mut store) = create_store();
    let root = TempDir::new().unwrap();

    // Create a deeply nested path (20 levels)
    let mut path = root.path().to_path_buf();
    for i in 0..20 {
        path = path.join(format!("level{}", i));
    }
    fs::create_dir_all(&path).unwrap();
    fs::write(path.join("deep.rs"), "fn deep() {}").unwrap();

    let input = IndexInput {
        paths: vec![root.path().to_string_lossy().to_string()],
        options: None,
    };

    let output = llmx_index_handler(&mut store, input).expect("Should handle deep paths");
    assert_eq!(output.stats.total_files, 1);
}

#[test]
fn test_spaces_in_paths() {
    let (_storage, mut store) = create_store();
    let root = TempDir::new().unwrap();

    let dir_with_spaces = root.path().join("path with spaces");
    fs::create_dir_all(&dir_with_spaces).unwrap();
    fs::write(dir_with_spaces.join("file with spaces.rs"), "fn spacy() {}").unwrap();

    let input = IndexInput {
        paths: vec![root.path().to_string_lossy().to_string()],
        options: None,
    };

    let output = llmx_index_handler(&mut store, input).expect("Should handle spaces in paths");
    assert_eq!(output.stats.total_files, 1);
}

#[test]
fn test_unicode_filenames() {
    let (_storage, mut store) = create_store();
    let root = TempDir::new().unwrap();

    // Various unicode filenames
    let filenames = ["æ—¥æœ¬èªž.rs", "ä¸­æ–‡.rs", "í•œêµ­ì–´.rs", "Ã©mojiðŸŽ‰.rs"];

    for name in filenames {
        let path = root.path().join(name);
        if fs::write(&path, format!("fn {}() {{}}", name.chars().next().unwrap())).is_err() {
            // Skip if filesystem doesn't support this filename
            continue;
        }
    }

    let input = IndexInput {
        paths: vec![root.path().to_string_lossy().to_string()],
        options: None,
    };

    let output = llmx_index_handler(&mut store, input).expect("Should handle unicode filenames");
    // At least some files should have been indexed
    assert!(output.stats.total_files >= 0);
}

// ============================================================================
// Content Edge Cases
// ============================================================================

#[test]
fn test_empty_file() {
    let input = FileInput {
        path: "empty.txt".to_string(),
        data: vec![],
        mtime_ms: None,
        fingerprint_sha256: None,
    };

    let index = ingest_files(vec![input], IngestOptions::default());
    // Empty files should still be tracked
    assert_eq!(index.files.len(), 1);
}

#[test]
fn test_single_byte_file() {
    let input = FileInput {
        path: "single.txt".to_string(),
        data: vec![b'x'],
        mtime_ms: None,
        fingerprint_sha256: None,
    };