---
chunk_index: 1058
ref: "ce48c237a64d"
id: "ce48c237a64d3ebc9c945d369bd722d2231718682c4fea3bfc4c3c8ab6a9f3ab"
slug: "llmx-l1-157"
path: "/home/zack/dev/llmx/ingestor-core/src/bin/llmx.rs"
kind: "text"
lines: [1, 157]
token_estimate: 1019
content_sha256: "feabbf372880508ee8309db4b8c48ce7e715a1cde2e5262d100e998beb70d87a"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

//! llmx CLI - Codebase indexing and semantic search
//!
//! A CLI for efficiently indexing and searching codebases with semantic chunking.
//! Designed for both human users and AI agents.

use anyhow::{Context, Result};
use clap::{Parser, Subcommand};
use ingestor_core::handlers::{
    llmx_explore_handler, llmx_get_chunk_handler, llmx_index_handler, llmx_manage_handler,
    llmx_search_handler, ExploreInput, IndexInput, IngestOptionsInput, ManageInput, SearchInput,
    SearchFiltersInput, IndexStore,
};
use ingestor_core::{export_llm, export_manifest_json, export_zip};
use std::fs;
use std::path::PathBuf;
use std::time::Instant;

#[derive(Parser)]
#[command(name = "llmx", version, about = "Codebase indexing and semantic search")]
struct Cli {
    #[command(subcommand)]
    command: Commands,

    /// Output JSON format (for agents)
    #[arg(long, global = true)]
    json: bool,

    /// Target specific index ID (default: auto-detect from cwd)
    #[arg(long, global = true)]
    index_id: Option<String>,

    /// Override storage directory (default: ~/.llmx/indexes)
    #[arg(long, global = true)]
    storage_dir: Option<PathBuf>,
}

#[derive(Subcommand)]
enum Commands {
    /// Create or update index from paths
    Index {
        /// File or directory paths to index
        #[arg(required = true)]
        paths: Vec<PathBuf>,

        /// Target chunk size in characters (default: 4000)
        #[arg(long, default_value = "4000")]
        chunk_size: usize,

        /// Maximum file size in bytes (default: 10MB)
        #[arg(long, default_value = "10485760")]
        max_file: usize,
    },

    /// Search with inline content (token-budgeted)
    Search {
        /// Search query
        query: String,

        /// Token budget for inline content (default: 16000)
        #[arg(long, default_value = "16000")]
        max_tokens: usize,

        /// Maximum number of results (default: 10)
        #[arg(long, default_value = "10")]
        limit: usize,

        /// Filter by path prefix
        #[arg(long)]
        path: Option<String>,

        /// Filter by chunk kind (markdown, javascript, json, html, text, image)
        #[arg(long)]
        kind: Option<String>,

        /// Use hybrid BM25+embeddings search
        #[arg(long)]
        semantic: bool,
    },

    /// List files, outline, or symbols
    Explore {
        /// What to list: 'files', 'outline', or 'symbols'
        mode: String,

        /// Filter by path prefix
        #[arg(long)]
        path: Option<String>,
    },

    /// List all indexes
    List,

    /// Delete an index
    Delete {
        /// Index ID to delete
        id: String,
    },

    /// Export index to file
    Export {
        /// Index ID to export (or auto-detect from cwd)
        id: Option<String>,

        /// Output format: llm.md, zip, json, manifest (default: zip)
        #[arg(long, default_value = "zip")]
        format: String,

        /// Output file (default: stdout for llm.md/json, export.zip for zip)
        #[arg(long, short)]
        output: Option<PathBuf>,
    },

    /// Get single chunk by ID
    Get {
        /// Chunk ID or ref to retrieve
        chunk_id: String,
    },
}

fn main() -> Result<()> {
    let cli = Cli::parse();

    let storage_dir = cli.storage_dir.unwrap_or_else(|| {
        dirs::home_dir()
            .expect("Could not find home directory")
            .join(".llmx")
            .join("indexes")
    });

    let mut store = IndexStore::new(storage_dir)?;

    match cli.command {
        Commands::Index {
            paths,
            chunk_size,
            max_file,
        } => cmd_index(&mut store, paths, chunk_size, max_file, cli.json),

        Commands::Search {
            query,
            max_tokens,
            limit,
            path,
            kind,
            semantic,
        } => cmd_search(
            &mut store,
            &cli.index_id,
            query,
            max_tokens,
            limit,
            path,
            kind,
            semantic,
            cli.json,
        ),