---
chunk_index: 1064
ref: "846a5b3b6819"
id: "846a5b3b68198928a81ae7b24a4261634ca0a87dbf1364e74cb03b3dc2a37e3f"
slug: "chunk-l1-127"
path: "/home/zack/dev/llmx/ingestor-core/src/chunk.rs"
kind: "text"
lines: [1, 127]
token_estimate: 1066
content_sha256: "05c835eb18bc186a7ca000d62852e7272f8f93e4d718083bc53ac9866aa7db92"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

use crate::model::{Chunk, ChunkKind, IngestOptions};
use crate::util::{estimate_tokens, sha256_hex, short_id, slugify};
use regex::Regex;
use std::collections::BTreeMap;
#[cfg(feature = "treesitter")]
use tree_sitter::{Language, Node, Parser};

#[derive(Debug, Clone)]
struct ChunkDraft {
    kind: ChunkKind,
    start_line: usize,
    end_line: usize,
    content: String,
    heading_path: Vec<String>,
    symbol: Option<String>,
    address: Option<String>,
}

pub fn chunk_file(path: &str, text: &str, kind: ChunkKind, options: &IngestOptions) -> Vec<Chunk> {
    let drafts = match kind {
        ChunkKind::Markdown => chunk_markdown(text, options),
        ChunkKind::Json => chunk_json(text, options),
        ChunkKind::JavaScript => chunk_javascript(path, text, options),
        ChunkKind::Html => chunk_html(text, options),
        ChunkKind::Image => chunk_image(path),
        ChunkKind::Text | ChunkKind::Unknown => chunk_text(text, options),
    };
    finalize_chunks(path, drafts)
}

fn finalize_chunks(path: &str, drafts: Vec<ChunkDraft>) -> Vec<Chunk> {
    let mut chunks = Vec::new();
    let mut hash_counts: BTreeMap<String, usize> = BTreeMap::new();
    for (index, draft) in drafts.into_iter().enumerate() {
        let content_hash = sha256_hex(draft.content.as_bytes());
        let count = hash_counts.entry(content_hash.clone()).or_insert(0);
        let occurrence = *count;
        *count += 1;
        let id_seed = format!("{}\n{}\n{}", path, content_hash, occurrence);
        let id = sha256_hex(id_seed.as_bytes());
        let token_estimate = estimate_tokens(&draft.content);
        let content = draft.content;
        let short_id = short_id(&id, 12);
        let slug = make_slug(
            path,
            draft.kind,
            &draft.heading_path,
            &draft.symbol,
            &draft.address,
            draft.start_line,
            draft.end_line,
        );
        chunks.push(Chunk {
            id,
            short_id,
            slug,
            path: path.to_string(),
            kind: draft.kind,
            chunk_index: index,
            start_line: draft.start_line,
            end_line: draft.end_line,
            content,
            content_hash,
            token_estimate,
            heading_path: draft.heading_path,
            symbol: draft.symbol,
            address: draft.address,
            asset_path: None,
        });
    }
    chunks
}

fn chunk_image(path: &str) -> Vec<ChunkDraft> {
    let name = path
        .rsplit('/')
        .next()
        .unwrap_or(path)
        .trim()
        .to_string();
    vec![ChunkDraft {
        kind: ChunkKind::Image,
        start_line: 1,
        end_line: 1,
        content: format!("Image: {name}\nSource: {path}"),
        heading_path: Vec::new(),
        symbol: None,
        address: None,
    }]
}

fn chunk_markdown(text: &str, options: &IngestOptions) -> Vec<ChunkDraft> {
    let mut drafts = Vec::new();
    let mut buf: Vec<String> = Vec::new();
    let mut heading_stack: Vec<String> = Vec::new();
    let mut current_heading = heading_stack.clone();
    let mut start_line = 1;
    let mut in_fence = false;
    let heading_re = Regex::new(r"^(#{1,6})\s+(.+)").unwrap();

    for (idx, line) in text.lines().enumerate() {
        let line_no = idx + 1;
        let trimmed = line.trim();
        if trimmed.starts_with("```") || trimmed.starts_with("~~~") {
            in_fence = !in_fence;
        }

        if !in_fence {
            if let Some(caps) = heading_re.captures(line) {
                flush_chunk(&mut drafts, &mut buf, &current_heading, ChunkFlushParams {
                    start_line,
                    end_line: line_no - 1,
                    kind: ChunkKind::Markdown,
                    symbol: None,
                    address: None,
                });
                let level = caps.get(1).unwrap().as_str().len();
                let title = caps.get(2).unwrap().as_str().trim().to_string();
                while heading_stack.len() >= level {
                    heading_stack.pop();
                }
                heading_stack.push(title);
                current_heading = heading_stack.clone();
                start_line = line_no;
            }
        }