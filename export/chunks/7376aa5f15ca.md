---
chunk_index: 198
ref: "7376aa5f15ca"
id: "7376aa5f15ca0e3b175c29535ed87e1f2d70c26158a7f80f6e0851c42f005b4c"
slug: "cutting-edge-enhancements--implementation"
path: "/home/zack/dev/llmx/docs/CUTTING_EDGE_ENHANCEMENTS.md"
kind: "markdown"
lines: [496, 609]
token_estimate: 739
content_sha256: "eba01b8246fd2246bafbb057a2600f027e27c5988173853b87731578be29f520"
compacted: false
heading_path: ["Cutting-Edge Enhancements for Phases 1-4","6. Incremental Indexing with Filesystem Watching üëÅÔ∏è","Implementation"]
symbol: null
address: null
asset_path: null
---

### Implementation

**1. Add file watcher**:
```rust
// src/mcp/watcher.rs
use notify::{Watcher, RecursiveMode, Event};

pub struct IncrementalIndexer {
    watcher: RecommendedWatcher,
    index_store: Arc<Mutex<IndexStore>>,
    debouncer: Debouncer,
}

impl IncrementalIndexer {
    pub fn watch(&mut self, index_id: &str, paths: Vec<PathBuf>) -> Result<()> {
        let (tx, rx) = channel();
        
        let watcher = notify::recommended_watcher(move |event| {
            tx.send(event).unwrap();
        })?;
        
        for path in paths {
            watcher.watch(&path, RecursiveMode::Recursive)?;
        }
        
        // Process events
        tokio::spawn(async move {
            while let Ok(event) = rx.recv() {
                self.handle_event(index_id, event).await;
            }
        });
    }
    
    async fn handle_event(&mut self, index_id: &str, event: Event) {
        match event.kind {
            EventKind::Modify(_) => {
                // File modified: reindex just this file
                self.update_file(index_id, &event.path).await;
            }
            EventKind::Create(_) => {
                // New file: add to index
                self.add_file(index_id, &event.path).await;
            }
            EventKind::Remove(_) => {
                // File deleted: remove from index
                self.remove_file(index_id, &event.path).await;
            }
            _ => {}
        }
    }
}
```

**2. Partial index updates**:
```rust
pub async fn update_file(&mut self, index_id: &str, path: &Path) {
    let mut store = self.index_store.lock().await;
    let index = store.load_mut(index_id)?;
    
    // Remove old chunks for this file
    index.chunks.retain(|c| c.path != path);
    
    // Remove from inverted index
    for old_chunk in old_chunks {
        index.inverted_index.remove_chunk(&old_chunk.id);
    }
    
    // Re-chunk the file
    let new_chunks = chunk_file(path)?;
    
    // Add to index
    for chunk in new_chunks {
        index.chunks.push(chunk.clone());
        index.inverted_index.add_chunk(&chunk);
    }
    
    // Save (atomic write)
    store.save(index_id, index)?;
}
```

**3. Debouncing** (handle rapid changes):
```rust
pub struct Debouncer {
    pending: HashMap<PathBuf, Instant>,
    delay: Duration,
}

impl Debouncer {
    pub fn should_process(&mut self, path: &Path) -> bool {
        let now = Instant::now();
        
        if let Some(last) = self.pending.get(path) {
            if now.duration_since(*last) < self.delay {
                // Too soon, skip
                return false;
            }
        }
        
        self.pending.insert(path.to_path_buf(), now);
        true
    }
}
```

**Benefits**:
- **Fast updates**: Only reindex changed files
- **Always current**: Index stays in sync with codebase
- **No manual reindex**: Happens automatically

**When to implement**: Phase 6 (after baseline stable)

---