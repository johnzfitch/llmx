---
chunk_index: 1104
ref: "6abcb86a1737"
id: "6abcb86a173740bc25b71a69272090cfd1fe1e5106cf30da51e582520e2ba93c"
slug: "edge-cases-tests-l279-419"
path: "/home/zack/dev/llmx/ingestor-core/tests/edge_cases_tests.rs"
kind: "text"
lines: [279, 419]
token_estimate: 1038
content_sha256: "affdbb4281faf7b7fee84f7de204ac114d6e13f2744540ea334783af1afcc1f3"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

#[test]
fn test_search_empty_query() {
    let (_storage, mut store) = create_store();
    let root = TempDir::new().unwrap();

    fs::write(root.path().join("test.rs"), "fn main() {}").unwrap();

    let idx_input = IndexInput {
        paths: vec![root.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    let search_input = SearchInput {
        index_id: idx_output.index_id,
        query: "".to_string(),
        filters: None,
        limit: Some(10),
        max_tokens: Some(16000),
        use_semantic: None,
    };

    // Empty query should return results (or empty set, but not error)
    let result = llmx_search_handler(&mut store, search_input);
    assert!(result.is_ok());
}

#[test]
fn test_search_very_long_query() {
    let (_storage, mut store) = create_store();
    let root = TempDir::new().unwrap();

    fs::write(root.path().join("test.rs"), "fn main() {}").unwrap();

    let idx_input = IndexInput {
        paths: vec![root.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    let search_input = SearchInput {
        index_id: idx_output.index_id,
        query: "word ".repeat(200), // 1000+ chars
        filters: None,
        limit: Some(10),
        max_tokens: Some(16000),
        use_semantic: None,
    };

    let result = llmx_search_handler(&mut store, search_input);
    assert!(result.is_ok());
}

#[test]
fn test_search_special_characters() {
    let (_storage, mut store) = create_store();
    let root = TempDir::new().unwrap();

    fs::write(root.path().join("test.rs"), "fn main() {}").unwrap();

    let idx_input = IndexInput {
        paths: vec![root.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    // Query with regex metacharacters
    let search_input = SearchInput {
        index_id: idx_output.index_id,
        query: "fn.*()".to_string(), // Contains regex chars
        filters: None,
        limit: Some(10),
        max_tokens: Some(16000),
        use_semantic: None,
    };

    let result = llmx_search_handler(&mut store, search_input);
    assert!(result.is_ok());
}

#[test]
fn test_search_unicode_query() {
    let (_storage, mut store) = create_store();
    let root = TempDir::new().unwrap();

    fs::write(root.path().join("test.md"), "# こんにちは\n\nHello world").unwrap();

    let idx_input = IndexInput {
        paths: vec![root.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    let search_input = SearchInput {
        index_id: idx_output.index_id,
        query: "こんにちは".to_string(),
        filters: None,
        limit: Some(10),
        max_tokens: Some(16000),
        use_semantic: None,
    };

    let result = llmx_search_handler(&mut store, search_input);
    assert!(result.is_ok());
}

#[test]
fn test_search_token_budget_zero() {
    let (_storage, mut store) = create_store();
    let root = TempDir::new().unwrap();

    fs::write(root.path().join("test.rs"), "fn main() {}").unwrap();

    let idx_input = IndexInput {
        paths: vec![root.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    let search_input = SearchInput {
        index_id: idx_output.index_id,
        query: "fn".to_string(),
        filters: None,
        limit: Some(10),
        max_tokens: Some(0), // Zero budget
        use_semantic: None,
    };

    let result = llmx_search_handler(&mut store, search_input);
    // Should succeed but return no inline content
    assert!(result.is_ok());
    let output = result.unwrap();
    // Results should be empty or all in truncated_ids
    if output.total_matches > 0 {
        assert!(
            output.results.is_empty() || output.truncated_ids.is_some(),
            "With zero budget, results should be empty or truncated"
        );
    }
}