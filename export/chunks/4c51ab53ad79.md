---
chunk_index: 1195
ref: "4c51ab53ad79"
id: "4c51ab53ad796d6f0bd7353a7d63ad9f0245b730858c097a5236ee193926b635"
slug: "handler-tests-l421-561"
path: "/home/zack/dev/llmx/ingestor-core/tests/handler_tests.rs"
kind: "text"
lines: [421, 561]
token_estimate: 1042
content_sha256: "237349a4fd919cbe42b8ba292d8c04a4f7466c7af4c5a27a86ee3722d66ca79f"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    let explore_input = ExploreInput {
        index_id: idx_output.index_id,
        mode: "invalid_mode".to_string(),
        path_filter: None,
    };

    let result = llmx_explore_handler(&mut store, explore_input);
    assert!(result.is_err(), "Should fail with invalid mode");
}

// ============================================================================
// Manage Handler Tests
// ============================================================================

#[test]
fn test_handler_manage_list_empty() {
    let (_storage, mut store) = create_store();

    let input = ManageInput {
        action: "list".to_string(),
        index_id: None,
    };

    let output = llmx_manage_handler(&mut store, input).expect("List should succeed");
    assert!(output.success);
    assert!(output.indexes.is_some());
    assert!(output.indexes.unwrap().is_empty());
}

#[test]
fn test_handler_manage_list_with_indexes() {
    let (_storage, mut store) = create_store();
    let project = create_test_project();

    // Create an index first
    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    llmx_index_handler(&mut store, idx_input).unwrap();

    // Now list
    let input = ManageInput {
        action: "list".to_string(),
        index_id: None,
    };

    let output = llmx_manage_handler(&mut store, input).expect("List should succeed");
    assert!(output.success);
    let indexes = output.indexes.unwrap();
    assert_eq!(indexes.len(), 1);
}

#[test]
fn test_handler_manage_delete() {
    let (_storage, mut store) = create_store();
    let project = create_test_project();

    // Create an index
    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    // Delete it
    let delete_input = ManageInput {
        action: "delete".to_string(),
        index_id: Some(idx_output.index_id.clone()),
    };

    let output = llmx_manage_handler(&mut store, delete_input).expect("Delete should succeed");
    assert!(output.success);

    // Verify it's gone
    let list_input = ManageInput {
        action: "list".to_string(),
        index_id: None,
    };
    let list_output = llmx_manage_handler(&mut store, list_input).unwrap();
    assert!(list_output.indexes.unwrap().is_empty());
}

#[test]
fn test_handler_manage_delete_missing_id() {
    let (_storage, mut store) = create_store();

    let input = ManageInput {
        action: "delete".to_string(),
        index_id: None,
    };

    let result = llmx_manage_handler(&mut store, input);
    assert!(result.is_err(), "Delete without ID should fail");
}

#[test]
fn test_handler_manage_invalid_action() {
    let (_storage, mut store) = create_store();

    let input = ManageInput {
        action: "invalid_action".to_string(),
        index_id: None,
    };

    let result = llmx_manage_handler(&mut store, input);
    assert!(result.is_err(), "Invalid action should fail");
}

// ============================================================================
// Get Chunk Handler Tests
// ============================================================================

#[test]
fn test_handler_get_chunk_by_full_id() {
    let (_storage, mut store) = create_store();
    let project = create_test_project();

    let idx_input = IndexInput {
        paths: vec![project.path().to_string_lossy().to_string()],
        options: None,
    };
    let idx_output = llmx_index_handler(&mut store, idx_input).unwrap();

    // Get a chunk ID from search
    let search_input = SearchInput {
        index_id: idx_output.index_id.clone(),
        query: "fn".to_string(),
        filters: None,
        limit: Some(1),
        max_tokens: Some(16000),
        use_semantic: None,
    };
    let search_output = llmx_search_handler(&mut store, search_input).unwrap();