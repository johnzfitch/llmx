---
chunk_index: 1071
ref: "65d260f18a38"
id: "65d260f18a386e13201d0c89109533003245efac869c8ced5a28310519272bf6"
slug: "export-l122-266"
path: "/home/zack/dev/llmx/ingestor-core/src/export.rs"
kind: "text"
lines: [122, 266]
token_estimate: 1099
content_sha256: "e669b6e22abd55241c4211f5f82cd526f3843bf1b7aac0e9799c8d8a86dcfbe4"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

pub fn export_manifest_json(index: &IndexFile) -> String {
    export_manifest(index)
}

#[derive(Debug, Serialize)]
struct ManifestV2 {
    format_version: u32,
    index_id: String,
    files: Vec<FileMeta>,
    paths: Vec<String>,
    kinds: Vec<String>,
    chunk_columns: Vec<&'static str>,
    chunks: Vec<ManifestChunkRowV2>,
}

#[derive(Debug, Serialize)]
struct ManifestChunkRowV2(
    String,         // ref
    String,         // id
    String,         // slug
    usize,          // path_i
    usize,          // kind_i
    usize,          // start_line
    usize,          // end_line
    usize,          // token_estimate
    String,         // content_sha256
    Vec<String>,    // heading_path
    Option<String>, // symbol
    Option<String>, // address
    Option<String>, // asset_path
);

fn export_manifest(index: &IndexFile) -> String {
    let mut chunks = index.chunks.clone();
    chunks.sort_by(chunk_sort);
    let refs = if index.chunk_refs.is_empty() {
        build_chunk_refs(&chunks)
    } else {
        index.chunk_refs.clone()
    };

    let mut paths: Vec<String> = Vec::new();
    let mut path_ids: BTreeMap<String, usize> = BTreeMap::new();
    let mut kinds: Vec<String> = Vec::new();
    let mut kind_ids: BTreeMap<String, usize> = BTreeMap::new();

    let mut rows = Vec::new();
    for chunk in chunks {
        let chunk_ref = refs
            .get(chunk.id.as_str())
            .cloned()
            .unwrap_or_else(|| chunk.short_id.clone());

        let path_i = match path_ids.get(chunk.path.as_str()) {
            Some(id) => *id,
            None => {
                let id = paths.len();
                paths.push(chunk.path.clone());
                path_ids.insert(chunk.path.clone(), id);
                id
            }
        };

        let kind_label = kind_label(chunk.kind).to_string();
        let kind_i = match kind_ids.get(kind_label.as_str()) {
            Some(id) => *id,
            None => {
                let id = kinds.len();
                kinds.push(kind_label.clone());
                kind_ids.insert(kind_label, id);
                id
            }
        };

        rows.push(ManifestChunkRowV2(
            chunk_ref,
            chunk.id,
            chunk.slug,
            path_i,
            kind_i,
            chunk.start_line,
            chunk.end_line,
            chunk.token_estimate,
            chunk.content_hash,
            chunk.heading_path,
            chunk.symbol,
            chunk.address,
            chunk.asset_path,
        ));
    }

    let manifest = ManifestV2 {
        format_version: 2,
        index_id: index.index_id.clone(),
        files: index.files.clone(),
        paths,
        kinds,
        chunk_columns: vec![
            "ref",
            "id",
            "slug",
            "path_i",
            "kind_i",
            "start_line",
            "end_line",
            "token_estimate",
            "content_sha256",
            "heading_path",
            "symbol",
            "address",
            "asset_path",
        ],
        chunks: rows,
    };

    serde_json::to_string(&manifest).unwrap_or_default()
}

fn chunk_front_matter(index: usize, chunk: &Chunk, compacted: bool, chunk_ref: &str) -> String {
    let compact_flag = if compacted { "true" } else { "false" };
    let heading_json = serde_json::to_string(&chunk.heading_path).unwrap_or_else(|_| "[]".to_string());
    let symbol_json = serde_json::to_string(&chunk.symbol).unwrap_or_else(|_| "null".to_string());
    let address_json = serde_json::to_string(&chunk.address).unwrap_or_else(|_| "null".to_string());
    let asset_json = serde_json::to_string(&chunk.asset_path).unwrap_or_else(|_| "null".to_string());
    format!(
        "---\nchunk_index: {}\nref: {}\nid: {}\nslug: {}\npath: {}\nkind: {}\nlines: [{}, {}]\ntoken_estimate: {}\ncontent_sha256: {}\ncompacted: {}\nheading_path: {}\nsymbol: {}\naddress: {}\nasset_path: {}\n---",
        index,
        yaml_string(chunk_ref),
        yaml_string(&chunk.id),
        yaml_string(&chunk.slug),
        yaml_string(&chunk.path),
        yaml_string(kind_label(chunk.kind)),
        chunk.start_line,
        chunk.end_line,
        chunk.token_estimate,
        yaml_string(&chunk.content_hash),
        compact_flag,
        heading_json,
        symbol_json,
        address_json
        ,
        asset_json
    )
}