---
chunk_index: 1081
ref: "61630a6ba8ce"
id: "61630a6ba8ce33a1deb374f3b780b35895a1812912881898ef949a8603f010ce"
slug: "index-l139-280"
path: "/home/zack/dev/llmx/ingestor-core/src/index.rs"
kind: "text"
lines: [139, 280]
token_estimate: 1053
content_sha256: "c92a4eee92c6ed779e8f9860036794e74fb2fc4a1813cd60370191bad55d2a81"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

results.sort_by(|a, b| b.score.partial_cmp(&a.score).unwrap_or(std::cmp::Ordering::Equal));
    results.truncate(limit);
    results
}

fn passes_filters(chunk: &Chunk, filters: &SearchFilters) -> bool {
    if let Some(exact) = &filters.path_exact {
        if chunk.path != *exact {
            return false;
        }
    }
    if let Some(prefix) = &filters.path_prefix {
        if !chunk.path.starts_with(prefix) {
            return false;
        }
    }
    if let Some(kind) = filters.kind {
        if chunk.kind != kind {
            return false;
        }
    }
    if let Some(prefix) = &filters.heading_prefix {
        let heading = chunk.heading_path.join("/");
        if !heading.starts_with(prefix) {
            return false;
        }
    }
    if let Some(prefix) = &filters.symbol_prefix {
        if let Some(symbol) = &chunk.symbol {
            if !symbol.starts_with(prefix) {
                return false;
            }
        } else {
            return false;
        }
    }
    true
}

pub fn list_outline(chunks: &[Chunk], path: &str) -> Vec<String> {
    let mut seen = BTreeMap::new();
    for chunk in chunks {
        if chunk.path != path {
            continue;
        }
        if !chunk.heading_path.is_empty() {
            let key = chunk.heading_path.join("/");
            seen.insert(key, ());
        }
    }
    seen.keys().cloned().collect()
}

pub fn list_symbols(chunks: &[Chunk], path: &str) -> Vec<String> {
    let mut seen = BTreeMap::new();
    for chunk in chunks {
        if chunk.path != path {
            continue;
        }
        if let Some(symbol) = &chunk.symbol {
            seen.insert(symbol.clone(), ());
        }
    }
    seen.keys().cloned().collect()
}

/// Vector search using cosine similarity.
///
/// Returns chunks sorted by similarity to query embedding (highest first).
#[cfg(feature = "embeddings")]
pub fn vector_search(
    chunks: &[Chunk],
    chunk_refs: &BTreeMap<String, String>,
    embeddings: &[Vec<f32>],
    query_embedding: &[f32],
    filters: &SearchFilters,
    limit: usize,
) -> Vec<SearchResult> {
    if embeddings.len() != chunks.len() {
        return Vec::new();
    }

    let mut results: Vec<(usize, f32)> = Vec::new();

    for (idx, chunk) in chunks.iter().enumerate() {
        if !passes_filters(chunk, filters) {
            continue;
        }

        let similarity = cosine_similarity(&embeddings[idx], query_embedding);
        results.push((idx, similarity));
    }

    results.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
    results.truncate(limit);

    results
        .into_iter()
        .map(|(idx, score)| {
            let chunk = &chunks[idx];
            let chunk_ref = chunk_refs
                .get(chunk.id.as_str())
                .cloned()
                .unwrap_or_else(|| chunk.short_id.clone());
            SearchResult {
                chunk_id: chunk.id.clone(),
                chunk_ref,
                score,
                path: chunk.path.clone(),
                start_line: chunk.start_line,
                end_line: chunk.end_line,
                snippet: snippet(&chunk.content, 200),
                heading_path: chunk.heading_path.clone(),
            }
        })
        .collect()
}

/// Hybrid search combining BM25 and semantic similarity.
///
/// Uses weighted score combination: `final_score = 0.5 * normalized_bm25 + 0.5 * semantic_similarity`
#[cfg(feature = "embeddings")]
pub fn hybrid_search(
    chunks: &[Chunk],
    inverted: &BTreeMap<String, TermEntry>,
    chunk_refs: &BTreeMap<String, String>,
    embeddings: &[Vec<f32>],
    query: &str,
    query_embedding: &[f32],
    filters: &SearchFilters,
    limit: usize,
) -> Vec<SearchResult> {
    let bm25_results = search_index(chunks, inverted, chunk_refs, query, filters, limit * 2);
    let semantic_results = vector_search(chunks, chunk_refs, embeddings, query_embedding, filters, limit * 2);

    let mut bm25_map: HashMap<String, f32> = HashMap::new();
    let mut max_bm25 = 0.0f32;
    for result in &bm25_results {
        max_bm25 = max_bm25.max(result.score);
        bm25_map.insert(result.chunk_id.clone(), result.score);
    }