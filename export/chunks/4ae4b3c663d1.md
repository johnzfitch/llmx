---
chunk_index: 244
ref: "4ae4b3c663d1"
id: "4ae4b3c663d14282161a306338c7f6dc1e51519dcf4e03acc8494a45fa1602ef"
slug: "llmcat-integration-plan--2-1-three-export-modes"
path: "/home/zack/dev/llmx/docs/LLMCAT_INTEGRATION_PLAN.md"
kind: "markdown"
lines: [233, 298]
token_estimate: 613
content_sha256: "3542d00d5b257acccff8dc065d8708987fed3cac951adce3f51bb1721433ed63"
compacted: false
heading_path: ["specho-v2 Integration for llm.cat: Token Efficiency Implementation","Phase 2: Export Variants","2.1: Three Export Modes"]
symbol: null
address: null
asset_path: null
---

### 2.1: Three Export Modes

**File**: `backend/exporter.py`

```python
class LLMCatExporter:
    """Generate token-optimized exports."""
    
    def __init__(self, chunks: List[Dict], quality_filter: ChunkQualityFilter):
        self.chunks = chunks
        self.filter = quality_filter
    
    def export_standard(self) -> str:
        """Standard llms.txt (all chunks)."""
        return self._generate_llmstxt(self.chunks, "Standard Export")
    
    def export_quality_filtered(self) -> Tuple[str, Dict]:
        """Quality-filtered export (min_quality=0.6)."""
        filtered, stats = self.filter.filter_chunks(self.chunks)
        content = self._generate_llmstxt(filtered, "Quality-Filtered Export")
        return content, stats
    
    def export_minimal(self) -> Tuple[str, Dict]:
        """Top 25% highest quality chunks only."""
        scored = [(c, self.filter._calculate_quality(c['content'])) 
                  for c in self.chunks]
        scored.sort(key=lambda x: x[1], reverse=True)
        
        top_25 = [c for c, _ in scored[:len(scored)//4]]
        
        stats = {
            'chunk_count': len(top_25),
            'original_count': len(self.chunks),
            'reduction_pct': 75.0
        }
        
        content = self._generate_llmstxt(top_25, "Minimal Export (Top 25%)")
        return content, stats
    
    def _generate_llmstxt(self, chunks: List[Dict], title: str) -> str:
        """Generate llms.txt format."""
        output = [f"# {title}\n"]
        
        if 'quality_score' in chunks[0]:
            avg_quality = sum(c['quality_score'] for c in chunks) / len(chunks)
            output.append(f"> Average quality: {avg_quality:.2f}\n")
            output.append(f"> Total chunks: {len(chunks)}\n\n")
        
        current_file = None
        for chunk in chunks:
            if chunk['path'] != current_file:
                quality_badge = ""
                if 'quality_score' in chunk:
                    stars = 'â­' * round(chunk['quality_score'] * 5)
                    quality_badge = f" [{stars} {chunk['quality_score']:.2f}]"
                
                output.append(f"\n## File: {chunk['path']}{quality_badge}\n\n")
                current_file = chunk['path']
            
            start, end = chunk['lines']
            output.append(f"Lines {start}-{end}:\n")
            output.append(f"{chunk['content']}\n\n")
        
        return ''.join(output)
```