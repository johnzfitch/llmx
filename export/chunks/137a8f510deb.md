---
chunk_index: 1199
ref: "137a8f510deb"
id: "137a8f510deb323e87d2ff568ba2a302526b8a3fb74b58d03c65bca6a2c5a02c"
slug: "hig-usability-tests-l293-436"
path: "/home/zack/dev/llmx/ingestor-core/tests/hig_usability_tests.rs"
kind: "text"
lines: [293, 436]
token_estimate: 1010
content_sha256: "99e8bb46c00df858e50e0c78716eda445c0842631696aa782bd5cad74cf9d21c"
compacted: false
heading_path: []
symbol: null
address: null
asset_path: null
---

// ============================================================================
// HIG Principle: Modelessness
// "Commands should work independently"
// ============================================================================

#[test]
fn test_hig_modelessness_commands_independent() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();

    // Each command should work without prior state
    llmx()
        .args(["list", "--storage-dir", storage.path().to_str().unwrap()])
        .assert()
        .success();

    // Index should work fresh
    llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success();

    // Search should work immediately after index
    llmx()
        .args([
            "search",
            "fn",
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .current_dir(project.path())
        .assert()
        .success();
}

// ============================================================================
// HIG Language Guidelines
// "Use clear, consistent, helpful language"
// ============================================================================

#[test]
fn test_hig_language_no_internal_jargon() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();

    let output = llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success();

    let stdout = String::from_utf8_lossy(&output.get_output().stdout);

    // Output should use user-friendly terms
    // Should NOT contain internal implementation details
    assert!(
        !stdout.contains("BTreeMap"),
        "Should not expose internal types"
    );
    assert!(
        !stdout.contains("inverted_index"),
        "Should not expose internal structures"
    );
    assert!(
        !stdout.contains("chunk_refs"),
        "Should not expose internal names"
    );
}

#[test]
fn test_hig_language_consistent_verbs() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();

    // "Created" for new index
    llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout(predicate::str::contains("Created").or(predicate::str::contains("Updated")));

    // "deleted" for removal
    let output = llmx()
        .args([
            "index",
            project.path().to_str().unwrap(),
            "--storage-dir",
            storage.path().to_str().unwrap(),
            "--json",
        ])
        .assert()
        .success();

    let stdout = String::from_utf8_lossy(&output.get_output().stdout);
    let json: serde_json::Value = serde_json::from_str(&stdout).unwrap();
    let index_id = json["index_id"].as_str().unwrap();

    llmx()
        .args([
            "delete",
            index_id,
            "--storage-dir",
            storage.path().to_str().unwrap(),
        ])
        .assert()
        .success()
        .stdout(predicate::str::contains("deleted"));
}

// ============================================================================
// User Control
// "Users should feel in control"
// ============================================================================

#[test]
fn test_hig_control_explicit_options() {
    // User should be able to control chunking behavior
    llmx()
        .args(["index", "--help"])
        .assert()
        .success()
        .stdout(predicate::str::contains("--chunk-size"))
        .stdout(predicate::str::contains("--max-file"));
}

#[test]
fn test_hig_control_limit_results() {
    let storage = TempDir::new().unwrap();
    let project = create_test_project();